# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'BackendArgs',
    'BackendArgsDict',
    'DiskArgs',
    'DiskArgsDict',
    'GroupArgs',
    'GroupArgsDict',
    'K8sNodeInputArgs',
    'K8sNodeInputArgsDict',
    'MetadataArgs',
    'MetadataArgsDict',
    'MountArgs',
    'MountArgsDict',
    'QSFSInputArgs',
    'QSFSInputArgsDict',
    'VMInputArgs',
    'VMInputArgsDict',
    'ZDBInputArgs',
    'ZDBInputArgsDict',
    'ZlogArgs',
    'ZlogArgsDict',
]

MYPY = False

if not MYPY:
    class BackendArgsDict(TypedDict):
        address: pulumi.Input[str]
        """
        Address of backend ZDB (e.g. [300:a582:c60c:df75:f6da:8a92:d5ed:71ad]:9900 or 60.60.60.60:9900)
        """
        namespace: pulumi.Input[str]
        """
        ZDB namespace
        """
        password: pulumi.Input[str]
        """
        Namespace password
        """
elif False:
    BackendArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackendArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 password: pulumi.Input[str]):
        """
        :param pulumi.Input[str] address: Address of backend ZDB (e.g. [300:a582:c60c:df75:f6da:8a92:d5ed:71ad]:9900 or 60.60.60.60:9900)
        :param pulumi.Input[str] namespace: ZDB namespace
        :param pulumi.Input[str] password: Namespace password
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        Address of backend ZDB (e.g. [300:a582:c60c:df75:f6da:8a92:d5ed:71ad]:9900 or 60.60.60.60:9900)
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        """
        ZDB namespace
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Namespace password
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)


if not MYPY:
    class DiskArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the disk workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
        """
        size: pulumi.Input[int]
        """
        The disk size in GB (type SSD)
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the disk workload, optional with no restrictions
        """
elif False:
    DiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiskArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 size: pulumi.Input[int],
                 description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the disk workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
        :param pulumi.Input[int] size: The disk size in GB (type SSD)
        :param pulumi.Input[str] description: The description of the disk workload, optional with no restrictions
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the disk workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        The disk size in GB (type SSD)
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the disk workload, optional with no restrictions
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class GroupArgsDict(TypedDict):
        backends: NotRequired[pulumi.Input[Sequence[pulumi.Input['BackendArgsDict']]]]
        """
        List of ZDB backends configurations
        """
elif False:
    GroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupArgs:
    def __init__(__self__, *,
                 backends: Optional[pulumi.Input[Sequence[pulumi.Input['BackendArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BackendArgs']]] backends: List of ZDB backends configurations
        """
        if backends is not None:
            pulumi.set(__self__, "backends", backends)

    @property
    @pulumi.getter
    def backends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BackendArgs']]]]:
        """
        List of ZDB backends configurations
        """
        return pulumi.get(self, "backends")

    @backends.setter
    def backends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BackendArgs']]]]):
        pulumi.set(self, "backends", value)


if not MYPY:
    class K8sNodeInputArgsDict(TypedDict):
        cpu: pulumi.Input[int]
        """
        The cpu units needed for the kubernetes node. Range in [1: 32]
        """
        disk_size: pulumi.Input[int]
        """
        Data disk size in GBs. Must be between 1GB and 10240GBs (10TBs)
        """
        memory: pulumi.Input[int]
        """
        The memory capacity for the kubernetes node in MB. Min is 250 MB
        """
        name: pulumi.Input[str]
        """
        The name of the kubernetes node, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
        """
        network_name: pulumi.Input[str]
        """
        The name of the network, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported. Network must exist
        """
        node_id: Any
        """
        The node ID to deploy the kubernetes node on, required and should match the requested resources
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the kubernetes node, optional with no restrictions
        """
        entry_point: NotRequired[pulumi.Input[str]]
        """
        The entry point for the flist. Example: /sbin/zinit init
        """
        flist: NotRequired[pulumi.Input[str]]
        """
        The flist to be mounted in the kubernetes node. Example: https://hub.grid.tf/tf-official-apps/base:latest.flist
        """
        flist_checksum: NotRequired[pulumi.Input[str]]
        """
        The checksum of the flist which should match the checksum of the given flist, optional
        """
        mycelium: NotRequired[pulumi.Input[bool]]
        """
        A flag to generate a random mycelium IP seed to support mycelium in the kubernetes node
        """
        mycelium_ip_seed: NotRequired[pulumi.Input[str]]
        """
        The seed used for mycelium IP generated for the kubernetes node. It's length should be 6
        """
        planetary: NotRequired[pulumi.Input[bool]]
        """
        A flag to enable generating a yggdrasil IP for the kubernetes node
        """
        public_ip: NotRequired[pulumi.Input[bool]]
        """
        A flag to enable generating a public IP for the kubernetes node, public node is required for it
        """
        public_ip6: NotRequired[pulumi.Input[bool]]
        """
        A flag to enable generating a public IPv6 for the kubernetes node, public node is required for it
        """
elif False:
    K8sNodeInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class K8sNodeInputArgs:
    def __init__(__self__, *,
                 cpu: pulumi.Input[int],
                 disk_size: pulumi.Input[int],
                 memory: pulumi.Input[int],
                 name: pulumi.Input[str],
                 network_name: pulumi.Input[str],
                 node_id: Any,
                 description: Optional[pulumi.Input[str]] = None,
                 entry_point: Optional[pulumi.Input[str]] = None,
                 flist: Optional[pulumi.Input[str]] = None,
                 flist_checksum: Optional[pulumi.Input[str]] = None,
                 mycelium: Optional[pulumi.Input[bool]] = None,
                 mycelium_ip_seed: Optional[pulumi.Input[str]] = None,
                 planetary: Optional[pulumi.Input[bool]] = None,
                 public_ip: Optional[pulumi.Input[bool]] = None,
                 public_ip6: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] cpu: The cpu units needed for the kubernetes node. Range in [1: 32]
        :param pulumi.Input[int] disk_size: Data disk size in GBs. Must be between 1GB and 10240GBs (10TBs)
        :param pulumi.Input[int] memory: The memory capacity for the kubernetes node in MB. Min is 250 MB
        :param pulumi.Input[str] name: The name of the kubernetes node, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
        :param pulumi.Input[str] network_name: The name of the network, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported. Network must exist
        :param Any node_id: The node ID to deploy the kubernetes node on, required and should match the requested resources
        :param pulumi.Input[str] description: The description of the kubernetes node, optional with no restrictions
        :param pulumi.Input[str] entry_point: The entry point for the flist. Example: /sbin/zinit init
        :param pulumi.Input[str] flist: The flist to be mounted in the kubernetes node. Example: https://hub.grid.tf/tf-official-apps/base:latest.flist
        :param pulumi.Input[str] flist_checksum: The checksum of the flist which should match the checksum of the given flist, optional
        :param pulumi.Input[bool] mycelium: A flag to generate a random mycelium IP seed to support mycelium in the kubernetes node
        :param pulumi.Input[str] mycelium_ip_seed: The seed used for mycelium IP generated for the kubernetes node. It's length should be 6
        :param pulumi.Input[bool] planetary: A flag to enable generating a yggdrasil IP for the kubernetes node
        :param pulumi.Input[bool] public_ip: A flag to enable generating a public IP for the kubernetes node, public node is required for it
        :param pulumi.Input[bool] public_ip6: A flag to enable generating a public IPv6 for the kubernetes node, public node is required for it
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_name", network_name)
        pulumi.set(__self__, "node_id", node_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if entry_point is None:
            entry_point = '/sbin/zinit init'
        if entry_point is not None:
            pulumi.set(__self__, "entry_point", entry_point)
        if flist is None:
            flist = 'https://hub.grid.tf/tf-official-apps/threefolddev-k3s-v1.31.0.flist'
        if flist is not None:
            pulumi.set(__self__, "flist", flist)
        if flist_checksum is not None:
            pulumi.set(__self__, "flist_checksum", flist_checksum)
        if mycelium is not None:
            pulumi.set(__self__, "mycelium", mycelium)
        if mycelium_ip_seed is not None:
            pulumi.set(__self__, "mycelium_ip_seed", mycelium_ip_seed)
        if planetary is not None:
            pulumi.set(__self__, "planetary", planetary)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if public_ip6 is not None:
            pulumi.set(__self__, "public_ip6", public_ip6)

    @property
    @pulumi.getter
    def cpu(self) -> pulumi.Input[int]:
        """
        The cpu units needed for the kubernetes node. Range in [1: 32]
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: pulumi.Input[int]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def disk_size(self) -> pulumi.Input[int]:
        """
        Data disk size in GBs. Must be between 1GB and 10240GBs (10TBs)
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter
    def memory(self) -> pulumi.Input[int]:
        """
        The memory capacity for the kubernetes node in MB. Min is 250 MB
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: pulumi.Input[int]):
        pulumi.set(self, "memory", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the kubernetes node, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def network_name(self) -> pulumi.Input[str]:
        """
        The name of the network, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported. Network must exist
        """
        return pulumi.get(self, "network_name")

    @network_name.setter
    def network_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_name", value)

    @property
    @pulumi.getter
    def node_id(self) -> Any:
        """
        The node ID to deploy the kubernetes node on, required and should match the requested resources
        """
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Any):
        pulumi.set(self, "node_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the kubernetes node, optional with no restrictions
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def entry_point(self) -> Optional[pulumi.Input[str]]:
        """
        The entry point for the flist. Example: /sbin/zinit init
        """
        return pulumi.get(self, "entry_point")

    @entry_point.setter
    def entry_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entry_point", value)

    @property
    @pulumi.getter
    def flist(self) -> Optional[pulumi.Input[str]]:
        """
        The flist to be mounted in the kubernetes node. Example: https://hub.grid.tf/tf-official-apps/base:latest.flist
        """
        return pulumi.get(self, "flist")

    @flist.setter
    def flist(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flist", value)

    @property
    @pulumi.getter
    def flist_checksum(self) -> Optional[pulumi.Input[str]]:
        """
        The checksum of the flist which should match the checksum of the given flist, optional
        """
        return pulumi.get(self, "flist_checksum")

    @flist_checksum.setter
    def flist_checksum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flist_checksum", value)

    @property
    @pulumi.getter
    def mycelium(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to generate a random mycelium IP seed to support mycelium in the kubernetes node
        """
        return pulumi.get(self, "mycelium")

    @mycelium.setter
    def mycelium(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mycelium", value)

    @property
    @pulumi.getter
    def mycelium_ip_seed(self) -> Optional[pulumi.Input[str]]:
        """
        The seed used for mycelium IP generated for the kubernetes node. It's length should be 6
        """
        return pulumi.get(self, "mycelium_ip_seed")

    @mycelium_ip_seed.setter
    def mycelium_ip_seed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mycelium_ip_seed", value)

    @property
    @pulumi.getter
    def planetary(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to enable generating a yggdrasil IP for the kubernetes node
        """
        return pulumi.get(self, "planetary")

    @planetary.setter
    def planetary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "planetary", value)

    @property
    @pulumi.getter
    def public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to enable generating a public IP for the kubernetes node, public node is required for it
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public_ip", value)

    @property
    @pulumi.getter
    def public_ip6(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to enable generating a public IPv6 for the kubernetes node, public node is required for it
        """
        return pulumi.get(self, "public_ip6")

    @public_ip6.setter
    def public_ip6(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public_ip6", value)


if not MYPY:
    class MetadataArgsDict(TypedDict):
        encryption_key: pulumi.Input[str]
        """
        64 long hex encoded encryption key (e.g. 0000000000000000000000000000000000000000000000000000000000000000)
        """
        prefix: pulumi.Input[str]
        """
        Data stored on the remote metadata is prefixed with
        """
        backends: NotRequired[pulumi.Input[Sequence[pulumi.Input['BackendArgsDict']]]]
        """
        List of ZDB backends configurations
        """
        encryption_algorithm: NotRequired[pulumi.Input[str]]
        """
        configuration to use for the encryption stage. Currently only AES is supported
        """
        type: NotRequired[pulumi.Input[str]]
        """
        configuration for the metadata store to use, currently only ZDB is supported
        """
elif False:
    MetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetadataArgs:
    def __init__(__self__, *,
                 encryption_key: pulumi.Input[str],
                 prefix: pulumi.Input[str],
                 backends: Optional[pulumi.Input[Sequence[pulumi.Input['BackendArgs']]]] = None,
                 encryption_algorithm: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] encryption_key: 64 long hex encoded encryption key (e.g. 0000000000000000000000000000000000000000000000000000000000000000)
        :param pulumi.Input[str] prefix: Data stored on the remote metadata is prefixed with
        :param pulumi.Input[Sequence[pulumi.Input['BackendArgs']]] backends: List of ZDB backends configurations
        :param pulumi.Input[str] encryption_algorithm: configuration to use for the encryption stage. Currently only AES is supported
        :param pulumi.Input[str] type: configuration for the metadata store to use, currently only ZDB is supported
        """
        pulumi.set(__self__, "encryption_key", encryption_key)
        pulumi.set(__self__, "prefix", prefix)
        if backends is not None:
            pulumi.set(__self__, "backends", backends)
        if encryption_algorithm is not None:
            pulumi.set(__self__, "encryption_algorithm", encryption_algorithm)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def encryption_key(self) -> pulumi.Input[str]:
        """
        64 long hex encoded encryption key (e.g. 0000000000000000000000000000000000000000000000000000000000000000)
        """
        return pulumi.get(self, "encryption_key")

    @encryption_key.setter
    def encryption_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "encryption_key", value)

    @property
    @pulumi.getter
    def prefix(self) -> pulumi.Input[str]:
        """
        Data stored on the remote metadata is prefixed with
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: pulumi.Input[str]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def backends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BackendArgs']]]]:
        """
        List of ZDB backends configurations
        """
        return pulumi.get(self, "backends")

    @backends.setter
    def backends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BackendArgs']]]]):
        pulumi.set(self, "backends", value)

    @property
    @pulumi.getter
    def encryption_algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        configuration to use for the encryption stage. Currently only AES is supported
        """
        return pulumi.get(self, "encryption_algorithm")

    @encryption_algorithm.setter
    def encryption_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_algorithm", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        configuration for the metadata store to use, currently only ZDB is supported
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MountArgsDict(TypedDict):
        mount_point: pulumi.Input[str]
        """
        The mount point of the disk/volume
        """
        name: pulumi.Input[str]
        """
        The name of the mounted disk/volume, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
        """
elif False:
    MountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MountArgs:
    def __init__(__self__, *,
                 mount_point: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] mount_point: The mount point of the disk/volume
        :param pulumi.Input[str] name: The name of the mounted disk/volume, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
        """
        pulumi.set(__self__, "mount_point", mount_point)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def mount_point(self) -> pulumi.Input[str]:
        """
        The mount point of the disk/volume
        """
        return pulumi.get(self, "mount_point")

    @mount_point.setter
    def mount_point(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_point", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the mounted disk/volume, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class QSFSInputArgsDict(TypedDict):
        cache: pulumi.Input[int]
        """
        The size of the fuse mountpoint on the node in MBs (holds qsfs local data before pushing)
        """
        encryption_key: pulumi.Input[str]
        """
        64 long hex encoded encryption key (e.g. 0000000000000000000000000000000000000000000000000000000000000000)
        """
        expected_shards: pulumi.Input[int]
        """
        The amount of shards which are generated when the data is encoded. Essentially, this is the amount of shards which is needed to be able to recover the data, and some disposable shards which could be lost. The amount of disposable shards can be calculated as expected_shards - minimal_shards
        """
        groups: pulumi.Input[Sequence[pulumi.Input['GroupArgsDict']]]
        """
        The backend groups to write the data to
        """
        max_zdb_data_dir_size: pulumi.Input[int]
        """
        Maximum size of the data dir in MiB, if this is set and the sum of the file sizes in the data dir gets higher than this value, the least used, already encoded file will be removed
        """
        metadata: pulumi.Input['MetadataArgsDict']
        """
        List of ZDB backends configurations
        """
        minimal_shards: pulumi.Input[int]
        """
        The minimum amount of shards which are needed to recover the original data
        """
        name: pulumi.Input[str]
        """
        The name of the qsfs workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
        """
        redundant_groups: pulumi.Input[int]
        """
        The amount of groups which one should be able to loose while still being able to recover the original data
        """
        redundant_nodes: pulumi.Input[int]
        """
        The amount of nodes that can be lost in every group while still being able to recover the original data
        """
        compression_algorithm: NotRequired[pulumi.Input[str]]
        """
        configuration to use for the compression stage. Currently only snappy is supported
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the qsfs workload, optional with no restrictions
        """
        encryption_algorithm: NotRequired[pulumi.Input[str]]
        """
        configuration to use for the encryption stage. Currently only AES is supported
        """
elif False:
    QSFSInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QSFSInputArgs:
    def __init__(__self__, *,
                 cache: pulumi.Input[int],
                 encryption_key: pulumi.Input[str],
                 expected_shards: pulumi.Input[int],
                 groups: pulumi.Input[Sequence[pulumi.Input['GroupArgs']]],
                 max_zdb_data_dir_size: pulumi.Input[int],
                 metadata: pulumi.Input['MetadataArgs'],
                 minimal_shards: pulumi.Input[int],
                 name: pulumi.Input[str],
                 redundant_groups: pulumi.Input[int],
                 redundant_nodes: pulumi.Input[int],
                 compression_algorithm: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encryption_algorithm: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] cache: The size of the fuse mountpoint on the node in MBs (holds qsfs local data before pushing)
        :param pulumi.Input[str] encryption_key: 64 long hex encoded encryption key (e.g. 0000000000000000000000000000000000000000000000000000000000000000)
        :param pulumi.Input[int] expected_shards: The amount of shards which are generated when the data is encoded. Essentially, this is the amount of shards which is needed to be able to recover the data, and some disposable shards which could be lost. The amount of disposable shards can be calculated as expected_shards - minimal_shards
        :param pulumi.Input[Sequence[pulumi.Input['GroupArgs']]] groups: The backend groups to write the data to
        :param pulumi.Input[int] max_zdb_data_dir_size: Maximum size of the data dir in MiB, if this is set and the sum of the file sizes in the data dir gets higher than this value, the least used, already encoded file will be removed
        :param pulumi.Input['MetadataArgs'] metadata: List of ZDB backends configurations
        :param pulumi.Input[int] minimal_shards: The minimum amount of shards which are needed to recover the original data
        :param pulumi.Input[str] name: The name of the qsfs workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
        :param pulumi.Input[int] redundant_groups: The amount of groups which one should be able to loose while still being able to recover the original data
        :param pulumi.Input[int] redundant_nodes: The amount of nodes that can be lost in every group while still being able to recover the original data
        :param pulumi.Input[str] compression_algorithm: configuration to use for the compression stage. Currently only snappy is supported
        :param pulumi.Input[str] description: The description of the qsfs workload, optional with no restrictions
        :param pulumi.Input[str] encryption_algorithm: configuration to use for the encryption stage. Currently only AES is supported
        """
        pulumi.set(__self__, "cache", cache)
        pulumi.set(__self__, "encryption_key", encryption_key)
        pulumi.set(__self__, "expected_shards", expected_shards)
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "max_zdb_data_dir_size", max_zdb_data_dir_size)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "minimal_shards", minimal_shards)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "redundant_groups", redundant_groups)
        pulumi.set(__self__, "redundant_nodes", redundant_nodes)
        if compression_algorithm is not None:
            pulumi.set(__self__, "compression_algorithm", compression_algorithm)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encryption_algorithm is not None:
            pulumi.set(__self__, "encryption_algorithm", encryption_algorithm)

    @property
    @pulumi.getter
    def cache(self) -> pulumi.Input[int]:
        """
        The size of the fuse mountpoint on the node in MBs (holds qsfs local data before pushing)
        """
        return pulumi.get(self, "cache")

    @cache.setter
    def cache(self, value: pulumi.Input[int]):
        pulumi.set(self, "cache", value)

    @property
    @pulumi.getter
    def encryption_key(self) -> pulumi.Input[str]:
        """
        64 long hex encoded encryption key (e.g. 0000000000000000000000000000000000000000000000000000000000000000)
        """
        return pulumi.get(self, "encryption_key")

    @encryption_key.setter
    def encryption_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "encryption_key", value)

    @property
    @pulumi.getter
    def expected_shards(self) -> pulumi.Input[int]:
        """
        The amount of shards which are generated when the data is encoded. Essentially, this is the amount of shards which is needed to be able to recover the data, and some disposable shards which could be lost. The amount of disposable shards can be calculated as expected_shards - minimal_shards
        """
        return pulumi.get(self, "expected_shards")

    @expected_shards.setter
    def expected_shards(self, value: pulumi.Input[int]):
        pulumi.set(self, "expected_shards", value)

    @property
    @pulumi.getter
    def groups(self) -> pulumi.Input[Sequence[pulumi.Input['GroupArgs']]]:
        """
        The backend groups to write the data to
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: pulumi.Input[Sequence[pulumi.Input['GroupArgs']]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def max_zdb_data_dir_size(self) -> pulumi.Input[int]:
        """
        Maximum size of the data dir in MiB, if this is set and the sum of the file sizes in the data dir gets higher than this value, the least used, already encoded file will be removed
        """
        return pulumi.get(self, "max_zdb_data_dir_size")

    @max_zdb_data_dir_size.setter
    def max_zdb_data_dir_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_zdb_data_dir_size", value)

    @property
    @pulumi.getter
    def metadata(self) -> pulumi.Input['MetadataArgs']:
        """
        List of ZDB backends configurations
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: pulumi.Input['MetadataArgs']):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def minimal_shards(self) -> pulumi.Input[int]:
        """
        The minimum amount of shards which are needed to recover the original data
        """
        return pulumi.get(self, "minimal_shards")

    @minimal_shards.setter
    def minimal_shards(self, value: pulumi.Input[int]):
        pulumi.set(self, "minimal_shards", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the qsfs workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def redundant_groups(self) -> pulumi.Input[int]:
        """
        The amount of groups which one should be able to loose while still being able to recover the original data
        """
        return pulumi.get(self, "redundant_groups")

    @redundant_groups.setter
    def redundant_groups(self, value: pulumi.Input[int]):
        pulumi.set(self, "redundant_groups", value)

    @property
    @pulumi.getter
    def redundant_nodes(self) -> pulumi.Input[int]:
        """
        The amount of nodes that can be lost in every group while still being able to recover the original data
        """
        return pulumi.get(self, "redundant_nodes")

    @redundant_nodes.setter
    def redundant_nodes(self, value: pulumi.Input[int]):
        pulumi.set(self, "redundant_nodes", value)

    @property
    @pulumi.getter
    def compression_algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        configuration to use for the compression stage. Currently only snappy is supported
        """
        return pulumi.get(self, "compression_algorithm")

    @compression_algorithm.setter
    def compression_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression_algorithm", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the qsfs workload, optional with no restrictions
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def encryption_algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        configuration to use for the encryption stage. Currently only AES is supported
        """
        return pulumi.get(self, "encryption_algorithm")

    @encryption_algorithm.setter
    def encryption_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_algorithm", value)


if not MYPY:
    class VMInputArgsDict(TypedDict):
        cpu: pulumi.Input[int]
        """
        The cpu units needed for the virtual machine. Range in [1: 32]
        """
        flist: pulumi.Input[str]
        """
        The flist to be mounted in the virtual machine, required and should be valid. Example: https://hub.grid.tf/tf-official-apps/base:latest.flist
        """
        memory: pulumi.Input[int]
        """
        The memory capacity for the virtual machine in MB. Min is 250 MB
        """
        name: pulumi.Input[str]
        """
        The name of the virtual machine workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
        """
        network_name: pulumi.Input[str]
        """
        The name of the network, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported. Network must exist
        """
        node_id: Any
        """
        The node ID to deploy the virtual machine on, required and should match the requested resources
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the virtual machine workload, optional with no restrictions
        """
        entrypoint: NotRequired[pulumi.Input[str]]
        """
        The entry point for the flist. Example: /sbin/zinit init
        """
        env_vars: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The environment variables to be passed to the virtual machine. Example: SSH_KEY
        """
        flist_checksum: NotRequired[pulumi.Input[str]]
        """
        The checksum of the flist which should match the checksum of the given flist, optional
        """
        gpus: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of gpu IDs to be used in the virtual machine. GPU ID format: <slot>/<vendor>/<device>. Example: 0000:28:00.0/1002/731f
        """
        mounts: NotRequired[pulumi.Input[Sequence[pulumi.Input['MountArgsDict']]]]
        """
        A list of mounted disks or volumes
        """
        mycelium: NotRequired[pulumi.Input[bool]]
        """
        A flag to generate a random mycelium IP seed to support mycelium in the virtual machine
        """
        mycelium_ip_seed: NotRequired[pulumi.Input[str]]
        """
        The seed used for mycelium IP generated for the virtual machine. It's length should be 6
        """
        planetary: NotRequired[pulumi.Input[bool]]
        """
        A flag to enable generating a yggdrasil IP for the virtual machine
        """
        public_ip: NotRequired[pulumi.Input[bool]]
        """
        A flag to enable generating a public IP for the virtual machine, public node is required for it
        """
        public_ip6: NotRequired[pulumi.Input[bool]]
        """
        A flag to enable generating a public IPv6 for the virtual machine, public node is required for it
        """
        rootfs_size: NotRequired[pulumi.Input[int]]
        """
        The root fs size in GB (type SSD). Can be set as 0 to get the default minimum
        """
        zlogs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZlogArgsDict']]]]
        """
        A list of virtual machine loggers
        """
elif False:
    VMInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VMInputArgs:
    def __init__(__self__, *,
                 cpu: pulumi.Input[int],
                 flist: pulumi.Input[str],
                 memory: pulumi.Input[int],
                 name: pulumi.Input[str],
                 network_name: pulumi.Input[str],
                 node_id: Any,
                 description: Optional[pulumi.Input[str]] = None,
                 entrypoint: Optional[pulumi.Input[str]] = None,
                 env_vars: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 flist_checksum: Optional[pulumi.Input[str]] = None,
                 gpus: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 mounts: Optional[pulumi.Input[Sequence[pulumi.Input['MountArgs']]]] = None,
                 mycelium: Optional[pulumi.Input[bool]] = None,
                 mycelium_ip_seed: Optional[pulumi.Input[str]] = None,
                 planetary: Optional[pulumi.Input[bool]] = None,
                 public_ip: Optional[pulumi.Input[bool]] = None,
                 public_ip6: Optional[pulumi.Input[bool]] = None,
                 rootfs_size: Optional[pulumi.Input[int]] = None,
                 zlogs: Optional[pulumi.Input[Sequence[pulumi.Input['ZlogArgs']]]] = None):
        """
        :param pulumi.Input[int] cpu: The cpu units needed for the virtual machine. Range in [1: 32]
        :param pulumi.Input[str] flist: The flist to be mounted in the virtual machine, required and should be valid. Example: https://hub.grid.tf/tf-official-apps/base:latest.flist
        :param pulumi.Input[int] memory: The memory capacity for the virtual machine in MB. Min is 250 MB
        :param pulumi.Input[str] name: The name of the virtual machine workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
        :param pulumi.Input[str] network_name: The name of the network, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported. Network must exist
        :param Any node_id: The node ID to deploy the virtual machine on, required and should match the requested resources
        :param pulumi.Input[str] description: The description of the virtual machine workload, optional with no restrictions
        :param pulumi.Input[str] entrypoint: The entry point for the flist. Example: /sbin/zinit init
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] env_vars: The environment variables to be passed to the virtual machine. Example: SSH_KEY
        :param pulumi.Input[str] flist_checksum: The checksum of the flist which should match the checksum of the given flist, optional
        :param pulumi.Input[Sequence[pulumi.Input[str]]] gpus: A list of gpu IDs to be used in the virtual machine. GPU ID format: <slot>/<vendor>/<device>. Example: 0000:28:00.0/1002/731f
        :param pulumi.Input[Sequence[pulumi.Input['MountArgs']]] mounts: A list of mounted disks or volumes
        :param pulumi.Input[bool] mycelium: A flag to generate a random mycelium IP seed to support mycelium in the virtual machine
        :param pulumi.Input[str] mycelium_ip_seed: The seed used for mycelium IP generated for the virtual machine. It's length should be 6
        :param pulumi.Input[bool] planetary: A flag to enable generating a yggdrasil IP for the virtual machine
        :param pulumi.Input[bool] public_ip: A flag to enable generating a public IP for the virtual machine, public node is required for it
        :param pulumi.Input[bool] public_ip6: A flag to enable generating a public IPv6 for the virtual machine, public node is required for it
        :param pulumi.Input[int] rootfs_size: The root fs size in GB (type SSD). Can be set as 0 to get the default minimum
        :param pulumi.Input[Sequence[pulumi.Input['ZlogArgs']]] zlogs: A list of virtual machine loggers
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "flist", flist)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_name", network_name)
        pulumi.set(__self__, "node_id", node_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if entrypoint is not None:
            pulumi.set(__self__, "entrypoint", entrypoint)
        if env_vars is not None:
            pulumi.set(__self__, "env_vars", env_vars)
        if flist_checksum is not None:
            pulumi.set(__self__, "flist_checksum", flist_checksum)
        if gpus is not None:
            pulumi.set(__self__, "gpus", gpus)
        if mounts is not None:
            pulumi.set(__self__, "mounts", mounts)
        if mycelium is not None:
            pulumi.set(__self__, "mycelium", mycelium)
        if mycelium_ip_seed is not None:
            pulumi.set(__self__, "mycelium_ip_seed", mycelium_ip_seed)
        if planetary is not None:
            pulumi.set(__self__, "planetary", planetary)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if public_ip6 is not None:
            pulumi.set(__self__, "public_ip6", public_ip6)
        if rootfs_size is not None:
            pulumi.set(__self__, "rootfs_size", rootfs_size)
        if zlogs is not None:
            pulumi.set(__self__, "zlogs", zlogs)

    @property
    @pulumi.getter
    def cpu(self) -> pulumi.Input[int]:
        """
        The cpu units needed for the virtual machine. Range in [1: 32]
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: pulumi.Input[int]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def flist(self) -> pulumi.Input[str]:
        """
        The flist to be mounted in the virtual machine, required and should be valid. Example: https://hub.grid.tf/tf-official-apps/base:latest.flist
        """
        return pulumi.get(self, "flist")

    @flist.setter
    def flist(self, value: pulumi.Input[str]):
        pulumi.set(self, "flist", value)

    @property
    @pulumi.getter
    def memory(self) -> pulumi.Input[int]:
        """
        The memory capacity for the virtual machine in MB. Min is 250 MB
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: pulumi.Input[int]):
        pulumi.set(self, "memory", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the virtual machine workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def network_name(self) -> pulumi.Input[str]:
        """
        The name of the network, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported. Network must exist
        """
        return pulumi.get(self, "network_name")

    @network_name.setter
    def network_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_name", value)

    @property
    @pulumi.getter
    def node_id(self) -> Any:
        """
        The node ID to deploy the virtual machine on, required and should match the requested resources
        """
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Any):
        pulumi.set(self, "node_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the virtual machine workload, optional with no restrictions
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def entrypoint(self) -> Optional[pulumi.Input[str]]:
        """
        The entry point for the flist. Example: /sbin/zinit init
        """
        return pulumi.get(self, "entrypoint")

    @entrypoint.setter
    def entrypoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entrypoint", value)

    @property
    @pulumi.getter
    def env_vars(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The environment variables to be passed to the virtual machine. Example: SSH_KEY
        """
        return pulumi.get(self, "env_vars")

    @env_vars.setter
    def env_vars(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "env_vars", value)

    @property
    @pulumi.getter
    def flist_checksum(self) -> Optional[pulumi.Input[str]]:
        """
        The checksum of the flist which should match the checksum of the given flist, optional
        """
        return pulumi.get(self, "flist_checksum")

    @flist_checksum.setter
    def flist_checksum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flist_checksum", value)

    @property
    @pulumi.getter
    def gpus(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of gpu IDs to be used in the virtual machine. GPU ID format: <slot>/<vendor>/<device>. Example: 0000:28:00.0/1002/731f
        """
        return pulumi.get(self, "gpus")

    @gpus.setter
    def gpus(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "gpus", value)

    @property
    @pulumi.getter
    def mounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MountArgs']]]]:
        """
        A list of mounted disks or volumes
        """
        return pulumi.get(self, "mounts")

    @mounts.setter
    def mounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MountArgs']]]]):
        pulumi.set(self, "mounts", value)

    @property
    @pulumi.getter
    def mycelium(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to generate a random mycelium IP seed to support mycelium in the virtual machine
        """
        return pulumi.get(self, "mycelium")

    @mycelium.setter
    def mycelium(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mycelium", value)

    @property
    @pulumi.getter
    def mycelium_ip_seed(self) -> Optional[pulumi.Input[str]]:
        """
        The seed used for mycelium IP generated for the virtual machine. It's length should be 6
        """
        return pulumi.get(self, "mycelium_ip_seed")

    @mycelium_ip_seed.setter
    def mycelium_ip_seed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mycelium_ip_seed", value)

    @property
    @pulumi.getter
    def planetary(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to enable generating a yggdrasil IP for the virtual machine
        """
        return pulumi.get(self, "planetary")

    @planetary.setter
    def planetary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "planetary", value)

    @property
    @pulumi.getter
    def public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to enable generating a public IP for the virtual machine, public node is required for it
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public_ip", value)

    @property
    @pulumi.getter
    def public_ip6(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to enable generating a public IPv6 for the virtual machine, public node is required for it
        """
        return pulumi.get(self, "public_ip6")

    @public_ip6.setter
    def public_ip6(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public_ip6", value)

    @property
    @pulumi.getter
    def rootfs_size(self) -> Optional[pulumi.Input[int]]:
        """
        The root fs size in GB (type SSD). Can be set as 0 to get the default minimum
        """
        return pulumi.get(self, "rootfs_size")

    @rootfs_size.setter
    def rootfs_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rootfs_size", value)

    @property
    @pulumi.getter
    def zlogs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZlogArgs']]]]:
        """
        A list of virtual machine loggers
        """
        return pulumi.get(self, "zlogs")

    @zlogs.setter
    def zlogs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZlogArgs']]]]):
        pulumi.set(self, "zlogs", value)


if not MYPY:
    class ZDBInputArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the 0-db workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
        """
        password: pulumi.Input[str]
        """
        The 0-db password
        """
        size: pulumi.Input[int]
        """
        The 0-db size in GB (type HDD)
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the 0-db workload, optional with no restrictions
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        the enumeration of the modes 0-db can operate in (default user)
        """
        public: NotRequired[pulumi.Input[bool]]
        """
        A flag to make 0-db namespace public - readable by anyone
        """
elif False:
    ZDBInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZDBInputArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 password: pulumi.Input[str],
                 size: pulumi.Input[int],
                 description: Optional[pulumi.Input[str]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 public: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: The name of the 0-db workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
        :param pulumi.Input[str] password: The 0-db password
        :param pulumi.Input[int] size: The 0-db size in GB (type HDD)
        :param pulumi.Input[str] description: The description of the 0-db workload, optional with no restrictions
        :param pulumi.Input[str] mode: the enumeration of the modes 0-db can operate in (default user)
        :param pulumi.Input[bool] public: A flag to make 0-db namespace public - readable by anyone
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "size", size)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if mode is None:
            mode = (_utilities.get_env('') or 'user')
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if public is not None:
            pulumi.set(__self__, "public", public)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the 0-db workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The 0-db password
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        The 0-db size in GB (type HDD)
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the 0-db workload, optional with no restrictions
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        the enumeration of the modes 0-db can operate in (default user)
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def public(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to make 0-db namespace public - readable by anyone
        """
        return pulumi.get(self, "public")

    @public.setter
    def public(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public", value)


if not MYPY:
    class ZlogArgsDict(TypedDict):
        output: pulumi.Input[str]
        """
        The output logs URL, should be a valid url
        """
        zmachine: pulumi.Input[str]
        """
        The name of virtual machine, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
        """
elif False:
    ZlogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZlogArgs:
    def __init__(__self__, *,
                 output: pulumi.Input[str],
                 zmachine: pulumi.Input[str]):
        """
        :param pulumi.Input[str] output: The output logs URL, should be a valid url
        :param pulumi.Input[str] zmachine: The name of virtual machine, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
        """
        pulumi.set(__self__, "output", output)
        pulumi.set(__self__, "zmachine", zmachine)

    @property
    @pulumi.getter
    def output(self) -> pulumi.Input[str]:
        """
        The output logs URL, should be a valid url
        """
        return pulumi.get(self, "output")

    @output.setter
    def output(self, value: pulumi.Input[str]):
        pulumi.set(self, "output", value)

    @property
    @pulumi.getter
    def zmachine(self) -> pulumi.Input[str]:
        """
        The name of virtual machine, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
        """
        return pulumi.get(self, "zmachine")

    @zmachine.setter
    def zmachine(self, value: pulumi.Input[str]):
        pulumi.set(self, "zmachine", value)


