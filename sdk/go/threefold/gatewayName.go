// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package threefold

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/threefoldtech/pulumi-threefold/sdk/go/threefold/internal"
)

type GatewayName struct {
	pulumi.CustomResourceState

	// The backends of the gateway proxy. must be in the format ip:port if tls_passthrough is set, otherwise the format should be http://ip[:port]
	Backends pulumi.StringArrayOutput `pulumi:"backends"`
	// The deployment ID
	Contract_id pulumi.IntOutput `pulumi:"contract_id"`
	// The description of the virtual machine workload, optional with no restrictions
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The computed fully qualified domain name of the deployed workload
	Fqdn pulumi.StringOutput `pulumi:"fqdn"`
	// Domain prefix. The fqdn will be <name>.<gateway-domain>. This has to be unique within the deployment. It's required and cannot exceed 50 characters. Must contain only alphanumeric and underscore characters
	Name pulumi.StringOutput `pulumi:"name"`
	// The reserved name contract ID
	Name_contract_id pulumi.IntOutput `pulumi:"name_contract_id"`
	// Network name to join, if backend IP is private
	Network_name pulumi.StringPtrOutput `pulumi:"network_name"`
	// Mapping from each node to its deployment ID
	Node_deployment_id pulumi.IntMapOutput `pulumi:"node_deployment_id"`
	// The gateway's node ID
	Node_id pulumi.AnyOutput `pulumi:"node_id"`
	// The name of the solution for created contract to be consistent across threefold tooling (project name in deployment metadata)
	Solution_type pulumi.StringPtrOutput `pulumi:"solution_type"`
	// TLS passthrough controls the TLS termination, if false, the gateway will terminate the TLS, if True, it will only be terminated by the backend service
	Tls_passthrough pulumi.BoolPtrOutput `pulumi:"tls_passthrough"`
}

// NewGatewayName registers a new resource with the given unique name, arguments, and options.
func NewGatewayName(ctx *pulumi.Context,
	name string, args *GatewayNameArgs, opts ...pulumi.ResourceOption) (*GatewayName, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Backends == nil {
		return nil, errors.New("invalid value for required argument 'Backends'")
	}
	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	if args.Node_id == nil {
		return nil, errors.New("invalid value for required argument 'Node_id'")
	}
	if args.Solution_type == nil {
		args.Solution_type = pulumi.StringPtr("")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource GatewayName
	err := ctx.RegisterResource("threefold:index:GatewayName", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetGatewayName gets an existing GatewayName resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetGatewayName(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *GatewayNameState, opts ...pulumi.ResourceOption) (*GatewayName, error) {
	var resource GatewayName
	err := ctx.ReadResource("threefold:index:GatewayName", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering GatewayName resources.
type gatewayNameState struct {
}

type GatewayNameState struct {
}

func (GatewayNameState) ElementType() reflect.Type {
	return reflect.TypeOf((*gatewayNameState)(nil)).Elem()
}

type gatewayNameArgs struct {
	// The backends of the gateway proxy. must be in the format ip:port if tls_passthrough is set, otherwise the format should be http://ip[:port]
	Backends []string `pulumi:"backends"`
	// The description of the virtual machine workload, optional with no restrictions
	Description *string `pulumi:"description"`
	// Domain prefix. The fqdn will be <name>.<gateway-domain>. This has to be unique within the deployment. It's required and cannot exceed 50 characters. Must contain only alphanumeric and underscore characters
	Name string `pulumi:"name"`
	// Network name to join, if backend IP is private
	Network_name *string `pulumi:"network_name"`
	// The gateway's node ID
	Node_id interface{} `pulumi:"node_id"`
	// The name of the solution for created contract to be consistent across threefold tooling (project name in deployment metadata)
	Solution_type *string `pulumi:"solution_type"`
	// TLS passthrough controls the TLS termination, if false, the gateway will terminate the TLS, if True, it will only be terminated by the backend service
	Tls_passthrough *bool `pulumi:"tls_passthrough"`
}

// The set of arguments for constructing a GatewayName resource.
type GatewayNameArgs struct {
	// The backends of the gateway proxy. must be in the format ip:port if tls_passthrough is set, otherwise the format should be http://ip[:port]
	Backends pulumi.StringArrayInput
	// The description of the virtual machine workload, optional with no restrictions
	Description pulumi.StringPtrInput
	// Domain prefix. The fqdn will be <name>.<gateway-domain>. This has to be unique within the deployment. It's required and cannot exceed 50 characters. Must contain only alphanumeric and underscore characters
	Name pulumi.StringInput
	// Network name to join, if backend IP is private
	Network_name pulumi.StringPtrInput
	// The gateway's node ID
	Node_id pulumi.Input
	// The name of the solution for created contract to be consistent across threefold tooling (project name in deployment metadata)
	Solution_type pulumi.StringPtrInput
	// TLS passthrough controls the TLS termination, if false, the gateway will terminate the TLS, if True, it will only be terminated by the backend service
	Tls_passthrough pulumi.BoolPtrInput
}

func (GatewayNameArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*gatewayNameArgs)(nil)).Elem()
}

type GatewayNameInput interface {
	pulumi.Input

	ToGatewayNameOutput() GatewayNameOutput
	ToGatewayNameOutputWithContext(ctx context.Context) GatewayNameOutput
}

func (*GatewayName) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayName)(nil)).Elem()
}

func (i *GatewayName) ToGatewayNameOutput() GatewayNameOutput {
	return i.ToGatewayNameOutputWithContext(context.Background())
}

func (i *GatewayName) ToGatewayNameOutputWithContext(ctx context.Context) GatewayNameOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayNameOutput)
}

// GatewayNameArrayInput is an input type that accepts GatewayNameArray and GatewayNameArrayOutput values.
// You can construct a concrete instance of `GatewayNameArrayInput` via:
//
//	GatewayNameArray{ GatewayNameArgs{...} }
type GatewayNameArrayInput interface {
	pulumi.Input

	ToGatewayNameArrayOutput() GatewayNameArrayOutput
	ToGatewayNameArrayOutputWithContext(context.Context) GatewayNameArrayOutput
}

type GatewayNameArray []GatewayNameInput

func (GatewayNameArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GatewayName)(nil)).Elem()
}

func (i GatewayNameArray) ToGatewayNameArrayOutput() GatewayNameArrayOutput {
	return i.ToGatewayNameArrayOutputWithContext(context.Background())
}

func (i GatewayNameArray) ToGatewayNameArrayOutputWithContext(ctx context.Context) GatewayNameArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayNameArrayOutput)
}

// GatewayNameMapInput is an input type that accepts GatewayNameMap and GatewayNameMapOutput values.
// You can construct a concrete instance of `GatewayNameMapInput` via:
//
//	GatewayNameMap{ "key": GatewayNameArgs{...} }
type GatewayNameMapInput interface {
	pulumi.Input

	ToGatewayNameMapOutput() GatewayNameMapOutput
	ToGatewayNameMapOutputWithContext(context.Context) GatewayNameMapOutput
}

type GatewayNameMap map[string]GatewayNameInput

func (GatewayNameMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GatewayName)(nil)).Elem()
}

func (i GatewayNameMap) ToGatewayNameMapOutput() GatewayNameMapOutput {
	return i.ToGatewayNameMapOutputWithContext(context.Background())
}

func (i GatewayNameMap) ToGatewayNameMapOutputWithContext(ctx context.Context) GatewayNameMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayNameMapOutput)
}

type GatewayNameOutput struct{ *pulumi.OutputState }

func (GatewayNameOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayName)(nil)).Elem()
}

func (o GatewayNameOutput) ToGatewayNameOutput() GatewayNameOutput {
	return o
}

func (o GatewayNameOutput) ToGatewayNameOutputWithContext(ctx context.Context) GatewayNameOutput {
	return o
}

// The backends of the gateway proxy. must be in the format ip:port if tls_passthrough is set, otherwise the format should be http://ip[:port]
func (o GatewayNameOutput) Backends() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GatewayName) pulumi.StringArrayOutput { return v.Backends }).(pulumi.StringArrayOutput)
}

// The deployment ID
func (o GatewayNameOutput) Contract_id() pulumi.IntOutput {
	return o.ApplyT(func(v *GatewayName) pulumi.IntOutput { return v.Contract_id }).(pulumi.IntOutput)
}

// The description of the virtual machine workload, optional with no restrictions
func (o GatewayNameOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayName) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The computed fully qualified domain name of the deployed workload
func (o GatewayNameOutput) Fqdn() pulumi.StringOutput {
	return o.ApplyT(func(v *GatewayName) pulumi.StringOutput { return v.Fqdn }).(pulumi.StringOutput)
}

// Domain prefix. The fqdn will be <name>.<gateway-domain>. This has to be unique within the deployment. It's required and cannot exceed 50 characters. Must contain only alphanumeric and underscore characters
func (o GatewayNameOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *GatewayName) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The reserved name contract ID
func (o GatewayNameOutput) Name_contract_id() pulumi.IntOutput {
	return o.ApplyT(func(v *GatewayName) pulumi.IntOutput { return v.Name_contract_id }).(pulumi.IntOutput)
}

// Network name to join, if backend IP is private
func (o GatewayNameOutput) Network_name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayName) pulumi.StringPtrOutput { return v.Network_name }).(pulumi.StringPtrOutput)
}

// Mapping from each node to its deployment ID
func (o GatewayNameOutput) Node_deployment_id() pulumi.IntMapOutput {
	return o.ApplyT(func(v *GatewayName) pulumi.IntMapOutput { return v.Node_deployment_id }).(pulumi.IntMapOutput)
}

// The gateway's node ID
func (o GatewayNameOutput) Node_id() pulumi.AnyOutput {
	return o.ApplyT(func(v *GatewayName) pulumi.AnyOutput { return v.Node_id }).(pulumi.AnyOutput)
}

// The name of the solution for created contract to be consistent across threefold tooling (project name in deployment metadata)
func (o GatewayNameOutput) Solution_type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayName) pulumi.StringPtrOutput { return v.Solution_type }).(pulumi.StringPtrOutput)
}

// TLS passthrough controls the TLS termination, if false, the gateway will terminate the TLS, if True, it will only be terminated by the backend service
func (o GatewayNameOutput) Tls_passthrough() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *GatewayName) pulumi.BoolPtrOutput { return v.Tls_passthrough }).(pulumi.BoolPtrOutput)
}

type GatewayNameArrayOutput struct{ *pulumi.OutputState }

func (GatewayNameArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GatewayName)(nil)).Elem()
}

func (o GatewayNameArrayOutput) ToGatewayNameArrayOutput() GatewayNameArrayOutput {
	return o
}

func (o GatewayNameArrayOutput) ToGatewayNameArrayOutputWithContext(ctx context.Context) GatewayNameArrayOutput {
	return o
}

func (o GatewayNameArrayOutput) Index(i pulumi.IntInput) GatewayNameOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *GatewayName {
		return vs[0].([]*GatewayName)[vs[1].(int)]
	}).(GatewayNameOutput)
}

type GatewayNameMapOutput struct{ *pulumi.OutputState }

func (GatewayNameMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GatewayName)(nil)).Elem()
}

func (o GatewayNameMapOutput) ToGatewayNameMapOutput() GatewayNameMapOutput {
	return o
}

func (o GatewayNameMapOutput) ToGatewayNameMapOutputWithContext(ctx context.Context) GatewayNameMapOutput {
	return o
}

func (o GatewayNameMapOutput) MapIndex(k pulumi.StringInput) GatewayNameOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *GatewayName {
		return vs[0].(map[string]*GatewayName)[vs[1].(string)]
	}).(GatewayNameOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayNameInput)(nil)).Elem(), &GatewayName{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayNameArrayInput)(nil)).Elem(), GatewayNameArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayNameMapInput)(nil)).Elem(), GatewayNameMap{})
	pulumi.RegisterOutputType(GatewayNameOutput{})
	pulumi.RegisterOutputType(GatewayNameArrayOutput{})
	pulumi.RegisterOutputType(GatewayNameMapOutput{})
}
