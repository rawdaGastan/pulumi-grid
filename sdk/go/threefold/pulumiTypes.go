// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package threefold

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/threefoldtech/pulumi-threefold/sdk/go/threefold/internal"
)

var _ = internal.GetEnvOrDefault

type Backend struct {
	// Address of backend ZDB (e.g. [300:a582:c60c:df75:f6da:8a92:d5ed:71ad]:9900 or 60.60.60.60:9900)
	Address string `pulumi:"address"`
	// ZDB namespace
	Namespace string `pulumi:"namespace"`
	// Namespace password
	Password string `pulumi:"password"`
}

// BackendInput is an input type that accepts BackendArgs and BackendOutput values.
// You can construct a concrete instance of `BackendInput` via:
//
//	BackendArgs{...}
type BackendInput interface {
	pulumi.Input

	ToBackendOutput() BackendOutput
	ToBackendOutputWithContext(context.Context) BackendOutput
}

type BackendArgs struct {
	// Address of backend ZDB (e.g. [300:a582:c60c:df75:f6da:8a92:d5ed:71ad]:9900 or 60.60.60.60:9900)
	Address pulumi.StringInput `pulumi:"address"`
	// ZDB namespace
	Namespace pulumi.StringInput `pulumi:"namespace"`
	// Namespace password
	Password pulumi.StringInput `pulumi:"password"`
}

func (BackendArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Backend)(nil)).Elem()
}

func (i BackendArgs) ToBackendOutput() BackendOutput {
	return i.ToBackendOutputWithContext(context.Background())
}

func (i BackendArgs) ToBackendOutputWithContext(ctx context.Context) BackendOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendOutput)
}

// BackendArrayInput is an input type that accepts BackendArray and BackendArrayOutput values.
// You can construct a concrete instance of `BackendArrayInput` via:
//
//	BackendArray{ BackendArgs{...} }
type BackendArrayInput interface {
	pulumi.Input

	ToBackendArrayOutput() BackendArrayOutput
	ToBackendArrayOutputWithContext(context.Context) BackendArrayOutput
}

type BackendArray []BackendInput

func (BackendArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Backend)(nil)).Elem()
}

func (i BackendArray) ToBackendArrayOutput() BackendArrayOutput {
	return i.ToBackendArrayOutputWithContext(context.Background())
}

func (i BackendArray) ToBackendArrayOutputWithContext(ctx context.Context) BackendArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendArrayOutput)
}

type BackendOutput struct{ *pulumi.OutputState }

func (BackendOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Backend)(nil)).Elem()
}

func (o BackendOutput) ToBackendOutput() BackendOutput {
	return o
}

func (o BackendOutput) ToBackendOutputWithContext(ctx context.Context) BackendOutput {
	return o
}

// Address of backend ZDB (e.g. [300:a582:c60c:df75:f6da:8a92:d5ed:71ad]:9900 or 60.60.60.60:9900)
func (o BackendOutput) Address() pulumi.StringOutput {
	return o.ApplyT(func(v Backend) string { return v.Address }).(pulumi.StringOutput)
}

// ZDB namespace
func (o BackendOutput) Namespace() pulumi.StringOutput {
	return o.ApplyT(func(v Backend) string { return v.Namespace }).(pulumi.StringOutput)
}

// Namespace password
func (o BackendOutput) Password() pulumi.StringOutput {
	return o.ApplyT(func(v Backend) string { return v.Password }).(pulumi.StringOutput)
}

type BackendArrayOutput struct{ *pulumi.OutputState }

func (BackendArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Backend)(nil)).Elem()
}

func (o BackendArrayOutput) ToBackendArrayOutput() BackendArrayOutput {
	return o
}

func (o BackendArrayOutput) ToBackendArrayOutputWithContext(ctx context.Context) BackendArrayOutput {
	return o
}

func (o BackendArrayOutput) Index(i pulumi.IntInput) BackendOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Backend {
		return vs[0].([]Backend)[vs[1].(int)]
	}).(BackendOutput)
}

type Disk struct {
	// The description of the disk workload, optional with no restrictions
	Description *string `pulumi:"description"`
	// The name of the disk workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
	Name string `pulumi:"name"`
	// The disk size in GB (type SSD)
	Size int `pulumi:"size"`
}

// DiskInput is an input type that accepts DiskArgs and DiskOutput values.
// You can construct a concrete instance of `DiskInput` via:
//
//	DiskArgs{...}
type DiskInput interface {
	pulumi.Input

	ToDiskOutput() DiskOutput
	ToDiskOutputWithContext(context.Context) DiskOutput
}

type DiskArgs struct {
	// The description of the disk workload, optional with no restrictions
	Description pulumi.StringPtrInput `pulumi:"description"`
	// The name of the disk workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
	Name pulumi.StringInput `pulumi:"name"`
	// The disk size in GB (type SSD)
	Size pulumi.IntInput `pulumi:"size"`
}

func (DiskArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Disk)(nil)).Elem()
}

func (i DiskArgs) ToDiskOutput() DiskOutput {
	return i.ToDiskOutputWithContext(context.Background())
}

func (i DiskArgs) ToDiskOutputWithContext(ctx context.Context) DiskOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiskOutput)
}

// DiskArrayInput is an input type that accepts DiskArray and DiskArrayOutput values.
// You can construct a concrete instance of `DiskArrayInput` via:
//
//	DiskArray{ DiskArgs{...} }
type DiskArrayInput interface {
	pulumi.Input

	ToDiskArrayOutput() DiskArrayOutput
	ToDiskArrayOutputWithContext(context.Context) DiskArrayOutput
}

type DiskArray []DiskInput

func (DiskArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Disk)(nil)).Elem()
}

func (i DiskArray) ToDiskArrayOutput() DiskArrayOutput {
	return i.ToDiskArrayOutputWithContext(context.Background())
}

func (i DiskArray) ToDiskArrayOutputWithContext(ctx context.Context) DiskArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiskArrayOutput)
}

type DiskOutput struct{ *pulumi.OutputState }

func (DiskOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Disk)(nil)).Elem()
}

func (o DiskOutput) ToDiskOutput() DiskOutput {
	return o
}

func (o DiskOutput) ToDiskOutputWithContext(ctx context.Context) DiskOutput {
	return o
}

// The description of the disk workload, optional with no restrictions
func (o DiskOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Disk) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// The name of the disk workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
func (o DiskOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v Disk) string { return v.Name }).(pulumi.StringOutput)
}

// The disk size in GB (type SSD)
func (o DiskOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v Disk) int { return v.Size }).(pulumi.IntOutput)
}

type DiskArrayOutput struct{ *pulumi.OutputState }

func (DiskArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Disk)(nil)).Elem()
}

func (o DiskArrayOutput) ToDiskArrayOutput() DiskArrayOutput {
	return o
}

func (o DiskArrayOutput) ToDiskArrayOutputWithContext(ctx context.Context) DiskArrayOutput {
	return o
}

func (o DiskArrayOutput) Index(i pulumi.IntInput) DiskOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Disk {
		return vs[0].([]Disk)[vs[1].(int)]
	}).(DiskOutput)
}

type Group struct {
	// List of ZDB backends configurations
	Backends []Backend `pulumi:"backends"`
}

// GroupInput is an input type that accepts GroupArgs and GroupOutput values.
// You can construct a concrete instance of `GroupInput` via:
//
//	GroupArgs{...}
type GroupInput interface {
	pulumi.Input

	ToGroupOutput() GroupOutput
	ToGroupOutputWithContext(context.Context) GroupOutput
}

type GroupArgs struct {
	// List of ZDB backends configurations
	Backends BackendArrayInput `pulumi:"backends"`
}

func (GroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Group)(nil)).Elem()
}

func (i GroupArgs) ToGroupOutput() GroupOutput {
	return i.ToGroupOutputWithContext(context.Background())
}

func (i GroupArgs) ToGroupOutputWithContext(ctx context.Context) GroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupOutput)
}

// GroupArrayInput is an input type that accepts GroupArray and GroupArrayOutput values.
// You can construct a concrete instance of `GroupArrayInput` via:
//
//	GroupArray{ GroupArgs{...} }
type GroupArrayInput interface {
	pulumi.Input

	ToGroupArrayOutput() GroupArrayOutput
	ToGroupArrayOutputWithContext(context.Context) GroupArrayOutput
}

type GroupArray []GroupInput

func (GroupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Group)(nil)).Elem()
}

func (i GroupArray) ToGroupArrayOutput() GroupArrayOutput {
	return i.ToGroupArrayOutputWithContext(context.Background())
}

func (i GroupArray) ToGroupArrayOutputWithContext(ctx context.Context) GroupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupArrayOutput)
}

type GroupOutput struct{ *pulumi.OutputState }

func (GroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Group)(nil)).Elem()
}

func (o GroupOutput) ToGroupOutput() GroupOutput {
	return o
}

func (o GroupOutput) ToGroupOutputWithContext(ctx context.Context) GroupOutput {
	return o
}

// List of ZDB backends configurations
func (o GroupOutput) Backends() BackendArrayOutput {
	return o.ApplyT(func(v Group) []Backend { return v.Backends }).(BackendArrayOutput)
}

type GroupArrayOutput struct{ *pulumi.OutputState }

func (GroupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Group)(nil)).Elem()
}

func (o GroupArrayOutput) ToGroupArrayOutput() GroupArrayOutput {
	return o
}

func (o GroupArrayOutput) ToGroupArrayOutputWithContext(ctx context.Context) GroupArrayOutput {
	return o
}

func (o GroupArrayOutput) Index(i pulumi.IntInput) GroupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Group {
		return vs[0].([]Group)[vs[1].(int)]
	}).(GroupOutput)
}

type K8sNodeInput struct {
	// The cpu units needed for the kubernetes node. Range in [1: 32]
	Cpu int `pulumi:"cpu"`
	// The description of the kubernetes node, optional with no restrictions
	Description *string `pulumi:"description"`
	// Data disk size in GBs. Must be between 1GB and 10240GBs (10TBs)
	Disk_size int `pulumi:"disk_size"`
	// The entry point for the flist. Example: /sbin/zinit init
	Entry_point *string `pulumi:"entry_point"`
	// The flist to be mounted in the kubernetes node. Example: https://hub.grid.tf/tf-official-apps/base:latest.flist
	Flist *string `pulumi:"flist"`
	// The checksum of the flist which should match the checksum of the given flist, optional
	Flist_checksum *string `pulumi:"flist_checksum"`
	// The memory capacity for the kubernetes node in MB. Min is 250 MB
	Memory int `pulumi:"memory"`
	// A flag to generate a random mycelium IP seed to support mycelium in the kubernetes node
	Mycelium *bool `pulumi:"mycelium"`
	// The seed used for mycelium IP generated for the kubernetes node. It's length should be 6
	Mycelium_ip_seed *string `pulumi:"mycelium_ip_seed"`
	// The name of the kubernetes node, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
	Name string `pulumi:"name"`
	// The name of the network, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported. Network must exist
	Network_name string `pulumi:"network_name"`
	// The node ID to deploy the kubernetes node on, required and should match the requested resources
	Node_id interface{} `pulumi:"node_id"`
	// A flag to enable generating a yggdrasil IP for the kubernetes node
	Planetary *bool `pulumi:"planetary"`
	// A flag to enable generating a public IP for the kubernetes node, public node is required for it
	Public_ip *bool `pulumi:"public_ip"`
	// A flag to enable generating a public IPv6 for the kubernetes node, public node is required for it
	Public_ip6 *bool `pulumi:"public_ip6"`
}

// Defaults sets the appropriate defaults for K8sNodeInput
func (val *K8sNodeInput) Defaults() *K8sNodeInput {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Entry_point == nil {
		entry_point_ := "/sbin/zinit init"
		tmp.Entry_point = &entry_point_
	}
	if tmp.Flist == nil {
		flist_ := "https://hub.grid.tf/tf-official-apps/threefoldtech-k3s-latest.flist"
		tmp.Flist = &flist_
	}
	return &tmp
}

// K8sNodeInputInput is an input type that accepts K8sNodeInputArgs and K8sNodeInputOutput values.
// You can construct a concrete instance of `K8sNodeInputInput` via:
//
//	K8sNodeInputArgs{...}
type K8sNodeInputInput interface {
	pulumi.Input

	ToK8sNodeInputOutput() K8sNodeInputOutput
	ToK8sNodeInputOutputWithContext(context.Context) K8sNodeInputOutput
}

type K8sNodeInputArgs struct {
	// The cpu units needed for the kubernetes node. Range in [1: 32]
	Cpu pulumi.IntInput `pulumi:"cpu"`
	// The description of the kubernetes node, optional with no restrictions
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Data disk size in GBs. Must be between 1GB and 10240GBs (10TBs)
	Disk_size pulumi.IntInput `pulumi:"disk_size"`
	// The entry point for the flist. Example: /sbin/zinit init
	Entry_point pulumi.StringPtrInput `pulumi:"entry_point"`
	// The flist to be mounted in the kubernetes node. Example: https://hub.grid.tf/tf-official-apps/base:latest.flist
	Flist pulumi.StringPtrInput `pulumi:"flist"`
	// The checksum of the flist which should match the checksum of the given flist, optional
	Flist_checksum pulumi.StringPtrInput `pulumi:"flist_checksum"`
	// The memory capacity for the kubernetes node in MB. Min is 250 MB
	Memory pulumi.IntInput `pulumi:"memory"`
	// A flag to generate a random mycelium IP seed to support mycelium in the kubernetes node
	Mycelium pulumi.BoolPtrInput `pulumi:"mycelium"`
	// The seed used for mycelium IP generated for the kubernetes node. It's length should be 6
	Mycelium_ip_seed pulumi.StringPtrInput `pulumi:"mycelium_ip_seed"`
	// The name of the kubernetes node, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
	Name pulumi.StringInput `pulumi:"name"`
	// The name of the network, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported. Network must exist
	Network_name pulumi.StringInput `pulumi:"network_name"`
	// The node ID to deploy the kubernetes node on, required and should match the requested resources
	Node_id pulumi.Input `pulumi:"node_id"`
	// A flag to enable generating a yggdrasil IP for the kubernetes node
	Planetary pulumi.BoolPtrInput `pulumi:"planetary"`
	// A flag to enable generating a public IP for the kubernetes node, public node is required for it
	Public_ip pulumi.BoolPtrInput `pulumi:"public_ip"`
	// A flag to enable generating a public IPv6 for the kubernetes node, public node is required for it
	Public_ip6 pulumi.BoolPtrInput `pulumi:"public_ip6"`
}

// Defaults sets the appropriate defaults for K8sNodeInputArgs
func (val *K8sNodeInputArgs) Defaults() *K8sNodeInputArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Entry_point == nil {
		tmp.Entry_point = pulumi.StringPtr("/sbin/zinit init")
	}
	if tmp.Flist == nil {
		tmp.Flist = pulumi.StringPtr("https://hub.grid.tf/tf-official-apps/threefoldtech-k3s-latest.flist")
	}
	return &tmp
}
func (K8sNodeInputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*K8sNodeInput)(nil)).Elem()
}

func (i K8sNodeInputArgs) ToK8sNodeInputOutput() K8sNodeInputOutput {
	return i.ToK8sNodeInputOutputWithContext(context.Background())
}

func (i K8sNodeInputArgs) ToK8sNodeInputOutputWithContext(ctx context.Context) K8sNodeInputOutput {
	return pulumi.ToOutputWithContext(ctx, i).(K8sNodeInputOutput)
}

// K8sNodeInputArrayInput is an input type that accepts K8sNodeInputArray and K8sNodeInputArrayOutput values.
// You can construct a concrete instance of `K8sNodeInputArrayInput` via:
//
//	K8sNodeInputArray{ K8sNodeInputArgs{...} }
type K8sNodeInputArrayInput interface {
	pulumi.Input

	ToK8sNodeInputArrayOutput() K8sNodeInputArrayOutput
	ToK8sNodeInputArrayOutputWithContext(context.Context) K8sNodeInputArrayOutput
}

type K8sNodeInputArray []K8sNodeInputInput

func (K8sNodeInputArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]K8sNodeInput)(nil)).Elem()
}

func (i K8sNodeInputArray) ToK8sNodeInputArrayOutput() K8sNodeInputArrayOutput {
	return i.ToK8sNodeInputArrayOutputWithContext(context.Background())
}

func (i K8sNodeInputArray) ToK8sNodeInputArrayOutputWithContext(ctx context.Context) K8sNodeInputArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(K8sNodeInputArrayOutput)
}

type K8sNodeInputOutput struct{ *pulumi.OutputState }

func (K8sNodeInputOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*K8sNodeInput)(nil)).Elem()
}

func (o K8sNodeInputOutput) ToK8sNodeInputOutput() K8sNodeInputOutput {
	return o
}

func (o K8sNodeInputOutput) ToK8sNodeInputOutputWithContext(ctx context.Context) K8sNodeInputOutput {
	return o
}

// The cpu units needed for the kubernetes node. Range in [1: 32]
func (o K8sNodeInputOutput) Cpu() pulumi.IntOutput {
	return o.ApplyT(func(v K8sNodeInput) int { return v.Cpu }).(pulumi.IntOutput)
}

// The description of the kubernetes node, optional with no restrictions
func (o K8sNodeInputOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v K8sNodeInput) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Data disk size in GBs. Must be between 1GB and 10240GBs (10TBs)
func (o K8sNodeInputOutput) Disk_size() pulumi.IntOutput {
	return o.ApplyT(func(v K8sNodeInput) int { return v.Disk_size }).(pulumi.IntOutput)
}

// The entry point for the flist. Example: /sbin/zinit init
func (o K8sNodeInputOutput) Entry_point() pulumi.StringPtrOutput {
	return o.ApplyT(func(v K8sNodeInput) *string { return v.Entry_point }).(pulumi.StringPtrOutput)
}

// The flist to be mounted in the kubernetes node. Example: https://hub.grid.tf/tf-official-apps/base:latest.flist
func (o K8sNodeInputOutput) Flist() pulumi.StringPtrOutput {
	return o.ApplyT(func(v K8sNodeInput) *string { return v.Flist }).(pulumi.StringPtrOutput)
}

// The checksum of the flist which should match the checksum of the given flist, optional
func (o K8sNodeInputOutput) Flist_checksum() pulumi.StringPtrOutput {
	return o.ApplyT(func(v K8sNodeInput) *string { return v.Flist_checksum }).(pulumi.StringPtrOutput)
}

// The memory capacity for the kubernetes node in MB. Min is 250 MB
func (o K8sNodeInputOutput) Memory() pulumi.IntOutput {
	return o.ApplyT(func(v K8sNodeInput) int { return v.Memory }).(pulumi.IntOutput)
}

// A flag to generate a random mycelium IP seed to support mycelium in the kubernetes node
func (o K8sNodeInputOutput) Mycelium() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v K8sNodeInput) *bool { return v.Mycelium }).(pulumi.BoolPtrOutput)
}

// The seed used for mycelium IP generated for the kubernetes node. It's length should be 6
func (o K8sNodeInputOutput) Mycelium_ip_seed() pulumi.StringPtrOutput {
	return o.ApplyT(func(v K8sNodeInput) *string { return v.Mycelium_ip_seed }).(pulumi.StringPtrOutput)
}

// The name of the kubernetes node, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
func (o K8sNodeInputOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v K8sNodeInput) string { return v.Name }).(pulumi.StringOutput)
}

// The name of the network, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported. Network must exist
func (o K8sNodeInputOutput) Network_name() pulumi.StringOutput {
	return o.ApplyT(func(v K8sNodeInput) string { return v.Network_name }).(pulumi.StringOutput)
}

// The node ID to deploy the kubernetes node on, required and should match the requested resources
func (o K8sNodeInputOutput) Node_id() pulumi.AnyOutput {
	return o.ApplyT(func(v K8sNodeInput) interface{} { return v.Node_id }).(pulumi.AnyOutput)
}

// A flag to enable generating a yggdrasil IP for the kubernetes node
func (o K8sNodeInputOutput) Planetary() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v K8sNodeInput) *bool { return v.Planetary }).(pulumi.BoolPtrOutput)
}

// A flag to enable generating a public IP for the kubernetes node, public node is required for it
func (o K8sNodeInputOutput) Public_ip() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v K8sNodeInput) *bool { return v.Public_ip }).(pulumi.BoolPtrOutput)
}

// A flag to enable generating a public IPv6 for the kubernetes node, public node is required for it
func (o K8sNodeInputOutput) Public_ip6() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v K8sNodeInput) *bool { return v.Public_ip6 }).(pulumi.BoolPtrOutput)
}

type K8sNodeInputArrayOutput struct{ *pulumi.OutputState }

func (K8sNodeInputArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]K8sNodeInput)(nil)).Elem()
}

func (o K8sNodeInputArrayOutput) ToK8sNodeInputArrayOutput() K8sNodeInputArrayOutput {
	return o
}

func (o K8sNodeInputArrayOutput) ToK8sNodeInputArrayOutputWithContext(ctx context.Context) K8sNodeInputArrayOutput {
	return o
}

func (o K8sNodeInputArrayOutput) Index(i pulumi.IntInput) K8sNodeInputOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) K8sNodeInput {
		return vs[0].([]K8sNodeInput)[vs[1].(int)]
	}).(K8sNodeInputOutput)
}

type Metadata struct {
	// List of ZDB backends configurations
	Backends []Backend `pulumi:"backends"`
	// configuration to use for the encryption stage. Currently only AES is supported
	Encryption_algorithm *string `pulumi:"encryption_algorithm"`
	// 64 long hex encoded encryption key (e.g. 0000000000000000000000000000000000000000000000000000000000000000)
	Encryption_key string `pulumi:"encryption_key"`
	// Data stored on the remote metadata is prefixed with
	Prefix string `pulumi:"prefix"`
	// configuration for the metadata store to use, currently only ZDB is supported
	Type *string `pulumi:"type"`
}

// MetadataInput is an input type that accepts MetadataArgs and MetadataOutput values.
// You can construct a concrete instance of `MetadataInput` via:
//
//	MetadataArgs{...}
type MetadataInput interface {
	pulumi.Input

	ToMetadataOutput() MetadataOutput
	ToMetadataOutputWithContext(context.Context) MetadataOutput
}

type MetadataArgs struct {
	// List of ZDB backends configurations
	Backends BackendArrayInput `pulumi:"backends"`
	// configuration to use for the encryption stage. Currently only AES is supported
	Encryption_algorithm pulumi.StringPtrInput `pulumi:"encryption_algorithm"`
	// 64 long hex encoded encryption key (e.g. 0000000000000000000000000000000000000000000000000000000000000000)
	Encryption_key pulumi.StringInput `pulumi:"encryption_key"`
	// Data stored on the remote metadata is prefixed with
	Prefix pulumi.StringInput `pulumi:"prefix"`
	// configuration for the metadata store to use, currently only ZDB is supported
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (MetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Metadata)(nil)).Elem()
}

func (i MetadataArgs) ToMetadataOutput() MetadataOutput {
	return i.ToMetadataOutputWithContext(context.Background())
}

func (i MetadataArgs) ToMetadataOutputWithContext(ctx context.Context) MetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetadataOutput)
}

type MetadataOutput struct{ *pulumi.OutputState }

func (MetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Metadata)(nil)).Elem()
}

func (o MetadataOutput) ToMetadataOutput() MetadataOutput {
	return o
}

func (o MetadataOutput) ToMetadataOutputWithContext(ctx context.Context) MetadataOutput {
	return o
}

// List of ZDB backends configurations
func (o MetadataOutput) Backends() BackendArrayOutput {
	return o.ApplyT(func(v Metadata) []Backend { return v.Backends }).(BackendArrayOutput)
}

// configuration to use for the encryption stage. Currently only AES is supported
func (o MetadataOutput) Encryption_algorithm() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Metadata) *string { return v.Encryption_algorithm }).(pulumi.StringPtrOutput)
}

// 64 long hex encoded encryption key (e.g. 0000000000000000000000000000000000000000000000000000000000000000)
func (o MetadataOutput) Encryption_key() pulumi.StringOutput {
	return o.ApplyT(func(v Metadata) string { return v.Encryption_key }).(pulumi.StringOutput)
}

// Data stored on the remote metadata is prefixed with
func (o MetadataOutput) Prefix() pulumi.StringOutput {
	return o.ApplyT(func(v Metadata) string { return v.Prefix }).(pulumi.StringOutput)
}

// configuration for the metadata store to use, currently only ZDB is supported
func (o MetadataOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Metadata) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type Mount struct {
	// The mount point of the disk/volume
	Mount_point string `pulumi:"mount_point"`
	// The name of the mounted disk/volume, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
	Name string `pulumi:"name"`
}

// MountInput is an input type that accepts MountArgs and MountOutput values.
// You can construct a concrete instance of `MountInput` via:
//
//	MountArgs{...}
type MountInput interface {
	pulumi.Input

	ToMountOutput() MountOutput
	ToMountOutputWithContext(context.Context) MountOutput
}

type MountArgs struct {
	// The mount point of the disk/volume
	Mount_point pulumi.StringInput `pulumi:"mount_point"`
	// The name of the mounted disk/volume, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
	Name pulumi.StringInput `pulumi:"name"`
}

func (MountArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Mount)(nil)).Elem()
}

func (i MountArgs) ToMountOutput() MountOutput {
	return i.ToMountOutputWithContext(context.Background())
}

func (i MountArgs) ToMountOutputWithContext(ctx context.Context) MountOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MountOutput)
}

// MountArrayInput is an input type that accepts MountArray and MountArrayOutput values.
// You can construct a concrete instance of `MountArrayInput` via:
//
//	MountArray{ MountArgs{...} }
type MountArrayInput interface {
	pulumi.Input

	ToMountArrayOutput() MountArrayOutput
	ToMountArrayOutputWithContext(context.Context) MountArrayOutput
}

type MountArray []MountInput

func (MountArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Mount)(nil)).Elem()
}

func (i MountArray) ToMountArrayOutput() MountArrayOutput {
	return i.ToMountArrayOutputWithContext(context.Background())
}

func (i MountArray) ToMountArrayOutputWithContext(ctx context.Context) MountArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MountArrayOutput)
}

type MountOutput struct{ *pulumi.OutputState }

func (MountOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Mount)(nil)).Elem()
}

func (o MountOutput) ToMountOutput() MountOutput {
	return o
}

func (o MountOutput) ToMountOutputWithContext(ctx context.Context) MountOutput {
	return o
}

// The mount point of the disk/volume
func (o MountOutput) Mount_point() pulumi.StringOutput {
	return o.ApplyT(func(v Mount) string { return v.Mount_point }).(pulumi.StringOutput)
}

// The name of the mounted disk/volume, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
func (o MountOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v Mount) string { return v.Name }).(pulumi.StringOutput)
}

type MountArrayOutput struct{ *pulumi.OutputState }

func (MountArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Mount)(nil)).Elem()
}

func (o MountArrayOutput) ToMountArrayOutput() MountArrayOutput {
	return o
}

func (o MountArrayOutput) ToMountArrayOutputWithContext(ctx context.Context) MountArrayOutput {
	return o
}

func (o MountArrayOutput) Index(i pulumi.IntInput) MountOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Mount {
		return vs[0].([]Mount)[vs[1].(int)]
	}).(MountOutput)
}

type QSFSComputed struct {
	// Exposed metrics endpoint
	Metrics_endpoint string `pulumi:"metrics_endpoint"`
}

// QSFSComputedInput is an input type that accepts QSFSComputedArgs and QSFSComputedOutput values.
// You can construct a concrete instance of `QSFSComputedInput` via:
//
//	QSFSComputedArgs{...}
type QSFSComputedInput interface {
	pulumi.Input

	ToQSFSComputedOutput() QSFSComputedOutput
	ToQSFSComputedOutputWithContext(context.Context) QSFSComputedOutput
}

type QSFSComputedArgs struct {
	// Exposed metrics endpoint
	Metrics_endpoint pulumi.StringInput `pulumi:"metrics_endpoint"`
}

func (QSFSComputedArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*QSFSComputed)(nil)).Elem()
}

func (i QSFSComputedArgs) ToQSFSComputedOutput() QSFSComputedOutput {
	return i.ToQSFSComputedOutputWithContext(context.Background())
}

func (i QSFSComputedArgs) ToQSFSComputedOutputWithContext(ctx context.Context) QSFSComputedOutput {
	return pulumi.ToOutputWithContext(ctx, i).(QSFSComputedOutput)
}

// QSFSComputedArrayInput is an input type that accepts QSFSComputedArray and QSFSComputedArrayOutput values.
// You can construct a concrete instance of `QSFSComputedArrayInput` via:
//
//	QSFSComputedArray{ QSFSComputedArgs{...} }
type QSFSComputedArrayInput interface {
	pulumi.Input

	ToQSFSComputedArrayOutput() QSFSComputedArrayOutput
	ToQSFSComputedArrayOutputWithContext(context.Context) QSFSComputedArrayOutput
}

type QSFSComputedArray []QSFSComputedInput

func (QSFSComputedArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]QSFSComputed)(nil)).Elem()
}

func (i QSFSComputedArray) ToQSFSComputedArrayOutput() QSFSComputedArrayOutput {
	return i.ToQSFSComputedArrayOutputWithContext(context.Background())
}

func (i QSFSComputedArray) ToQSFSComputedArrayOutputWithContext(ctx context.Context) QSFSComputedArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(QSFSComputedArrayOutput)
}

type QSFSComputedOutput struct{ *pulumi.OutputState }

func (QSFSComputedOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*QSFSComputed)(nil)).Elem()
}

func (o QSFSComputedOutput) ToQSFSComputedOutput() QSFSComputedOutput {
	return o
}

func (o QSFSComputedOutput) ToQSFSComputedOutputWithContext(ctx context.Context) QSFSComputedOutput {
	return o
}

// Exposed metrics endpoint
func (o QSFSComputedOutput) Metrics_endpoint() pulumi.StringOutput {
	return o.ApplyT(func(v QSFSComputed) string { return v.Metrics_endpoint }).(pulumi.StringOutput)
}

type QSFSComputedArrayOutput struct{ *pulumi.OutputState }

func (QSFSComputedArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]QSFSComputed)(nil)).Elem()
}

func (o QSFSComputedArrayOutput) ToQSFSComputedArrayOutput() QSFSComputedArrayOutput {
	return o
}

func (o QSFSComputedArrayOutput) ToQSFSComputedArrayOutputWithContext(ctx context.Context) QSFSComputedArrayOutput {
	return o
}

func (o QSFSComputedArrayOutput) Index(i pulumi.IntInput) QSFSComputedOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) QSFSComputed {
		return vs[0].([]QSFSComputed)[vs[1].(int)]
	}).(QSFSComputedOutput)
}

type QSFSInput struct {
	// The size of the fuse mountpoint on the node in MBs (holds qsfs local data before pushing)
	Cache int `pulumi:"cache"`
	// configuration to use for the compression stage. Currently only snappy is supported
	Compression_algorithm *string `pulumi:"compression_algorithm"`
	// The description of the qsfs workload, optional with no restrictions
	Description *string `pulumi:"description"`
	// configuration to use for the encryption stage. Currently only AES is supported
	Encryption_algorithm *string `pulumi:"encryption_algorithm"`
	// 64 long hex encoded encryption key (e.g. 0000000000000000000000000000000000000000000000000000000000000000)
	Encryption_key string `pulumi:"encryption_key"`
	// The amount of shards which are generated when the data is encoded. Essentially, this is the amount of shards which is needed to be able to recover the data, and some disposable shards which could be lost. The amount of disposable shards can be calculated as expected_shards - minimal_shards
	Expected_shards int `pulumi:"expected_shards"`
	// The backend groups to write the data to
	Groups []Group `pulumi:"groups"`
	// Maximum size of the data dir in MiB, if this is set and the sum of the file sizes in the data dir gets higher than this value, the least used, already encoded file will be removed
	Max_zdb_data_dir_size int `pulumi:"max_zdb_data_dir_size"`
	// List of ZDB backends configurations
	Metadata Metadata `pulumi:"metadata"`
	// The minimum amount of shards which are needed to recover the original data
	Minimal_shards int `pulumi:"minimal_shards"`
	// The name of the qsfs workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
	Name string `pulumi:"name"`
	// The amount of groups which one should be able to loose while still being able to recover the original data
	Redundant_groups int `pulumi:"redundant_groups"`
	// The amount of nodes that can be lost in every group while still being able to recover the original data
	Redundant_nodes int `pulumi:"redundant_nodes"`
}

// QSFSInputInput is an input type that accepts QSFSInputArgs and QSFSInputOutput values.
// You can construct a concrete instance of `QSFSInputInput` via:
//
//	QSFSInputArgs{...}
type QSFSInputInput interface {
	pulumi.Input

	ToQSFSInputOutput() QSFSInputOutput
	ToQSFSInputOutputWithContext(context.Context) QSFSInputOutput
}

type QSFSInputArgs struct {
	// The size of the fuse mountpoint on the node in MBs (holds qsfs local data before pushing)
	Cache pulumi.IntInput `pulumi:"cache"`
	// configuration to use for the compression stage. Currently only snappy is supported
	Compression_algorithm pulumi.StringPtrInput `pulumi:"compression_algorithm"`
	// The description of the qsfs workload, optional with no restrictions
	Description pulumi.StringPtrInput `pulumi:"description"`
	// configuration to use for the encryption stage. Currently only AES is supported
	Encryption_algorithm pulumi.StringPtrInput `pulumi:"encryption_algorithm"`
	// 64 long hex encoded encryption key (e.g. 0000000000000000000000000000000000000000000000000000000000000000)
	Encryption_key pulumi.StringInput `pulumi:"encryption_key"`
	// The amount of shards which are generated when the data is encoded. Essentially, this is the amount of shards which is needed to be able to recover the data, and some disposable shards which could be lost. The amount of disposable shards can be calculated as expected_shards - minimal_shards
	Expected_shards pulumi.IntInput `pulumi:"expected_shards"`
	// The backend groups to write the data to
	Groups GroupArrayInput `pulumi:"groups"`
	// Maximum size of the data dir in MiB, if this is set and the sum of the file sizes in the data dir gets higher than this value, the least used, already encoded file will be removed
	Max_zdb_data_dir_size pulumi.IntInput `pulumi:"max_zdb_data_dir_size"`
	// List of ZDB backends configurations
	Metadata MetadataInput `pulumi:"metadata"`
	// The minimum amount of shards which are needed to recover the original data
	Minimal_shards pulumi.IntInput `pulumi:"minimal_shards"`
	// The name of the qsfs workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
	Name pulumi.StringInput `pulumi:"name"`
	// The amount of groups which one should be able to loose while still being able to recover the original data
	Redundant_groups pulumi.IntInput `pulumi:"redundant_groups"`
	// The amount of nodes that can be lost in every group while still being able to recover the original data
	Redundant_nodes pulumi.IntInput `pulumi:"redundant_nodes"`
}

func (QSFSInputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*QSFSInput)(nil)).Elem()
}

func (i QSFSInputArgs) ToQSFSInputOutput() QSFSInputOutput {
	return i.ToQSFSInputOutputWithContext(context.Background())
}

func (i QSFSInputArgs) ToQSFSInputOutputWithContext(ctx context.Context) QSFSInputOutput {
	return pulumi.ToOutputWithContext(ctx, i).(QSFSInputOutput)
}

// QSFSInputArrayInput is an input type that accepts QSFSInputArray and QSFSInputArrayOutput values.
// You can construct a concrete instance of `QSFSInputArrayInput` via:
//
//	QSFSInputArray{ QSFSInputArgs{...} }
type QSFSInputArrayInput interface {
	pulumi.Input

	ToQSFSInputArrayOutput() QSFSInputArrayOutput
	ToQSFSInputArrayOutputWithContext(context.Context) QSFSInputArrayOutput
}

type QSFSInputArray []QSFSInputInput

func (QSFSInputArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]QSFSInput)(nil)).Elem()
}

func (i QSFSInputArray) ToQSFSInputArrayOutput() QSFSInputArrayOutput {
	return i.ToQSFSInputArrayOutputWithContext(context.Background())
}

func (i QSFSInputArray) ToQSFSInputArrayOutputWithContext(ctx context.Context) QSFSInputArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(QSFSInputArrayOutput)
}

type QSFSInputOutput struct{ *pulumi.OutputState }

func (QSFSInputOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*QSFSInput)(nil)).Elem()
}

func (o QSFSInputOutput) ToQSFSInputOutput() QSFSInputOutput {
	return o
}

func (o QSFSInputOutput) ToQSFSInputOutputWithContext(ctx context.Context) QSFSInputOutput {
	return o
}

// The size of the fuse mountpoint on the node in MBs (holds qsfs local data before pushing)
func (o QSFSInputOutput) Cache() pulumi.IntOutput {
	return o.ApplyT(func(v QSFSInput) int { return v.Cache }).(pulumi.IntOutput)
}

// configuration to use for the compression stage. Currently only snappy is supported
func (o QSFSInputOutput) Compression_algorithm() pulumi.StringPtrOutput {
	return o.ApplyT(func(v QSFSInput) *string { return v.Compression_algorithm }).(pulumi.StringPtrOutput)
}

// The description of the qsfs workload, optional with no restrictions
func (o QSFSInputOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v QSFSInput) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// configuration to use for the encryption stage. Currently only AES is supported
func (o QSFSInputOutput) Encryption_algorithm() pulumi.StringPtrOutput {
	return o.ApplyT(func(v QSFSInput) *string { return v.Encryption_algorithm }).(pulumi.StringPtrOutput)
}

// 64 long hex encoded encryption key (e.g. 0000000000000000000000000000000000000000000000000000000000000000)
func (o QSFSInputOutput) Encryption_key() pulumi.StringOutput {
	return o.ApplyT(func(v QSFSInput) string { return v.Encryption_key }).(pulumi.StringOutput)
}

// The amount of shards which are generated when the data is encoded. Essentially, this is the amount of shards which is needed to be able to recover the data, and some disposable shards which could be lost. The amount of disposable shards can be calculated as expected_shards - minimal_shards
func (o QSFSInputOutput) Expected_shards() pulumi.IntOutput {
	return o.ApplyT(func(v QSFSInput) int { return v.Expected_shards }).(pulumi.IntOutput)
}

// The backend groups to write the data to
func (o QSFSInputOutput) Groups() GroupArrayOutput {
	return o.ApplyT(func(v QSFSInput) []Group { return v.Groups }).(GroupArrayOutput)
}

// Maximum size of the data dir in MiB, if this is set and the sum of the file sizes in the data dir gets higher than this value, the least used, already encoded file will be removed
func (o QSFSInputOutput) Max_zdb_data_dir_size() pulumi.IntOutput {
	return o.ApplyT(func(v QSFSInput) int { return v.Max_zdb_data_dir_size }).(pulumi.IntOutput)
}

// List of ZDB backends configurations
func (o QSFSInputOutput) Metadata() MetadataOutput {
	return o.ApplyT(func(v QSFSInput) Metadata { return v.Metadata }).(MetadataOutput)
}

// The minimum amount of shards which are needed to recover the original data
func (o QSFSInputOutput) Minimal_shards() pulumi.IntOutput {
	return o.ApplyT(func(v QSFSInput) int { return v.Minimal_shards }).(pulumi.IntOutput)
}

// The name of the qsfs workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
func (o QSFSInputOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v QSFSInput) string { return v.Name }).(pulumi.StringOutput)
}

// The amount of groups which one should be able to loose while still being able to recover the original data
func (o QSFSInputOutput) Redundant_groups() pulumi.IntOutput {
	return o.ApplyT(func(v QSFSInput) int { return v.Redundant_groups }).(pulumi.IntOutput)
}

// The amount of nodes that can be lost in every group while still being able to recover the original data
func (o QSFSInputOutput) Redundant_nodes() pulumi.IntOutput {
	return o.ApplyT(func(v QSFSInput) int { return v.Redundant_nodes }).(pulumi.IntOutput)
}

type QSFSInputArrayOutput struct{ *pulumi.OutputState }

func (QSFSInputArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]QSFSInput)(nil)).Elem()
}

func (o QSFSInputArrayOutput) ToQSFSInputArrayOutput() QSFSInputArrayOutput {
	return o
}

func (o QSFSInputArrayOutput) ToQSFSInputArrayOutputWithContext(ctx context.Context) QSFSInputArrayOutput {
	return o
}

func (o QSFSInputArrayOutput) Index(i pulumi.IntInput) QSFSInputOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) QSFSInput {
		return vs[0].([]QSFSInput)[vs[1].(int)]
	}).(QSFSInputOutput)
}

type VMComputed struct {
	// The reserved public ipv4 if any
	Computed_ip string `pulumi:"computed_ip"`
	// The reserved public ipv6 if any
	Computed_ip6 string `pulumi:"computed_ip6"`
	// The url to access the vm via cloud console on private interface using wireguard
	Console_url string `pulumi:"console_url"`
	// The private wireguard IP of the vm
	Ip *string `pulumi:"ip"`
	// The allocated mycelium IP
	Mycelium_ip string `pulumi:"mycelium_ip"`
	// The seed used for mycelium IP generated for the virtual machine. It's length should be 6
	Mycelium_ip_seed string `pulumi:"mycelium_ip_seed"`
	// The allocated Yggdrasil IP
	Planetary_ip string `pulumi:"planetary_ip"`
}

// VMComputedInput is an input type that accepts VMComputedArgs and VMComputedOutput values.
// You can construct a concrete instance of `VMComputedInput` via:
//
//	VMComputedArgs{...}
type VMComputedInput interface {
	pulumi.Input

	ToVMComputedOutput() VMComputedOutput
	ToVMComputedOutputWithContext(context.Context) VMComputedOutput
}

type VMComputedArgs struct {
	// The reserved public ipv4 if any
	Computed_ip pulumi.StringInput `pulumi:"computed_ip"`
	// The reserved public ipv6 if any
	Computed_ip6 pulumi.StringInput `pulumi:"computed_ip6"`
	// The url to access the vm via cloud console on private interface using wireguard
	Console_url pulumi.StringInput `pulumi:"console_url"`
	// The private wireguard IP of the vm
	Ip pulumi.StringPtrInput `pulumi:"ip"`
	// The allocated mycelium IP
	Mycelium_ip pulumi.StringInput `pulumi:"mycelium_ip"`
	// The seed used for mycelium IP generated for the virtual machine. It's length should be 6
	Mycelium_ip_seed pulumi.StringInput `pulumi:"mycelium_ip_seed"`
	// The allocated Yggdrasil IP
	Planetary_ip pulumi.StringInput `pulumi:"planetary_ip"`
}

func (VMComputedArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VMComputed)(nil)).Elem()
}

func (i VMComputedArgs) ToVMComputedOutput() VMComputedOutput {
	return i.ToVMComputedOutputWithContext(context.Background())
}

func (i VMComputedArgs) ToVMComputedOutputWithContext(ctx context.Context) VMComputedOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VMComputedOutput)
}

// VMComputedArrayInput is an input type that accepts VMComputedArray and VMComputedArrayOutput values.
// You can construct a concrete instance of `VMComputedArrayInput` via:
//
//	VMComputedArray{ VMComputedArgs{...} }
type VMComputedArrayInput interface {
	pulumi.Input

	ToVMComputedArrayOutput() VMComputedArrayOutput
	ToVMComputedArrayOutputWithContext(context.Context) VMComputedArrayOutput
}

type VMComputedArray []VMComputedInput

func (VMComputedArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VMComputed)(nil)).Elem()
}

func (i VMComputedArray) ToVMComputedArrayOutput() VMComputedArrayOutput {
	return i.ToVMComputedArrayOutputWithContext(context.Background())
}

func (i VMComputedArray) ToVMComputedArrayOutputWithContext(ctx context.Context) VMComputedArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VMComputedArrayOutput)
}

// VMComputedMapInput is an input type that accepts VMComputedMap and VMComputedMapOutput values.
// You can construct a concrete instance of `VMComputedMapInput` via:
//
//	VMComputedMap{ "key": VMComputedArgs{...} }
type VMComputedMapInput interface {
	pulumi.Input

	ToVMComputedMapOutput() VMComputedMapOutput
	ToVMComputedMapOutputWithContext(context.Context) VMComputedMapOutput
}

type VMComputedMap map[string]VMComputedInput

func (VMComputedMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]VMComputed)(nil)).Elem()
}

func (i VMComputedMap) ToVMComputedMapOutput() VMComputedMapOutput {
	return i.ToVMComputedMapOutputWithContext(context.Background())
}

func (i VMComputedMap) ToVMComputedMapOutputWithContext(ctx context.Context) VMComputedMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VMComputedMapOutput)
}

type VMComputedOutput struct{ *pulumi.OutputState }

func (VMComputedOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VMComputed)(nil)).Elem()
}

func (o VMComputedOutput) ToVMComputedOutput() VMComputedOutput {
	return o
}

func (o VMComputedOutput) ToVMComputedOutputWithContext(ctx context.Context) VMComputedOutput {
	return o
}

// The reserved public ipv4 if any
func (o VMComputedOutput) Computed_ip() pulumi.StringOutput {
	return o.ApplyT(func(v VMComputed) string { return v.Computed_ip }).(pulumi.StringOutput)
}

// The reserved public ipv6 if any
func (o VMComputedOutput) Computed_ip6() pulumi.StringOutput {
	return o.ApplyT(func(v VMComputed) string { return v.Computed_ip6 }).(pulumi.StringOutput)
}

// The url to access the vm via cloud console on private interface using wireguard
func (o VMComputedOutput) Console_url() pulumi.StringOutput {
	return o.ApplyT(func(v VMComputed) string { return v.Console_url }).(pulumi.StringOutput)
}

// The private wireguard IP of the vm
func (o VMComputedOutput) Ip() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VMComputed) *string { return v.Ip }).(pulumi.StringPtrOutput)
}

// The allocated mycelium IP
func (o VMComputedOutput) Mycelium_ip() pulumi.StringOutput {
	return o.ApplyT(func(v VMComputed) string { return v.Mycelium_ip }).(pulumi.StringOutput)
}

// The seed used for mycelium IP generated for the virtual machine. It's length should be 6
func (o VMComputedOutput) Mycelium_ip_seed() pulumi.StringOutput {
	return o.ApplyT(func(v VMComputed) string { return v.Mycelium_ip_seed }).(pulumi.StringOutput)
}

// The allocated Yggdrasil IP
func (o VMComputedOutput) Planetary_ip() pulumi.StringOutput {
	return o.ApplyT(func(v VMComputed) string { return v.Planetary_ip }).(pulumi.StringOutput)
}

type VMComputedArrayOutput struct{ *pulumi.OutputState }

func (VMComputedArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VMComputed)(nil)).Elem()
}

func (o VMComputedArrayOutput) ToVMComputedArrayOutput() VMComputedArrayOutput {
	return o
}

func (o VMComputedArrayOutput) ToVMComputedArrayOutputWithContext(ctx context.Context) VMComputedArrayOutput {
	return o
}

func (o VMComputedArrayOutput) Index(i pulumi.IntInput) VMComputedOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VMComputed {
		return vs[0].([]VMComputed)[vs[1].(int)]
	}).(VMComputedOutput)
}

type VMComputedMapOutput struct{ *pulumi.OutputState }

func (VMComputedMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]VMComputed)(nil)).Elem()
}

func (o VMComputedMapOutput) ToVMComputedMapOutput() VMComputedMapOutput {
	return o
}

func (o VMComputedMapOutput) ToVMComputedMapOutputWithContext(ctx context.Context) VMComputedMapOutput {
	return o
}

func (o VMComputedMapOutput) MapIndex(k pulumi.StringInput) VMComputedOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) VMComputed {
		return vs[0].(map[string]VMComputed)[vs[1].(string)]
	}).(VMComputedOutput)
}

type VMInput struct {
	// The cpu units needed for the virtual machine. Range in [1: 32]
	Cpu int `pulumi:"cpu"`
	// The description of the virtual machine workload, optional with no restrictions
	Description *string `pulumi:"description"`
	// The entry point for the flist. Example: /sbin/zinit init
	Entrypoint *string `pulumi:"entrypoint"`
	// The environment variables to be passed to the virtual machine. Example: SSH_KEY
	Env_vars map[string]string `pulumi:"env_vars"`
	// The flist to be mounted in the virtual machine, required and should be valid. Example: https://hub.grid.tf/tf-official-apps/base:latest.flist
	Flist string `pulumi:"flist"`
	// The checksum of the flist which should match the checksum of the given flist, optional
	Flist_checksum *string `pulumi:"flist_checksum"`
	// A list of gpu IDs to be used in the virtual machine. GPU ID format: <slot>/<vendor>/<device>. Example: 0000:28:00.0/1002/731f
	Gpus []string `pulumi:"gpus"`
	// The memory capacity for the virtual machine in MB. Min is 250 MB
	Memory int `pulumi:"memory"`
	// A list of mounted disks or volumes
	Mounts []Mount `pulumi:"mounts"`
	// A flag to generate a random mycelium IP seed to support mycelium in the virtual machine
	Mycelium *bool `pulumi:"mycelium"`
	// The seed used for mycelium IP generated for the virtual machine. It's length should be 6
	Mycelium_ip_seed *string `pulumi:"mycelium_ip_seed"`
	// The name of the virtual machine workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
	Name string `pulumi:"name"`
	// The name of the network, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported. Network must exist
	Network_name string `pulumi:"network_name"`
	// The node ID to deploy the virtual machine on, required and should match the requested resources
	Node_id interface{} `pulumi:"node_id"`
	// A flag to enable generating a yggdrasil IP for the virtual machine
	Planetary *bool `pulumi:"planetary"`
	// A flag to enable generating a public IP for the virtual machine, public node is required for it
	Public_ip *bool `pulumi:"public_ip"`
	// A flag to enable generating a public IPv6 for the virtual machine, public node is required for it
	Public_ip6 *bool `pulumi:"public_ip6"`
	// The root fs size in GB (type SSD). Can be set as 0 to get the default minimum
	Rootfs_size *int `pulumi:"rootfs_size"`
	// A list of virtual machine loggers
	Zlogs []Zlog `pulumi:"zlogs"`
}

// VMInputInput is an input type that accepts VMInputArgs and VMInputOutput values.
// You can construct a concrete instance of `VMInputInput` via:
//
//	VMInputArgs{...}
type VMInputInput interface {
	pulumi.Input

	ToVMInputOutput() VMInputOutput
	ToVMInputOutputWithContext(context.Context) VMInputOutput
}

type VMInputArgs struct {
	// The cpu units needed for the virtual machine. Range in [1: 32]
	Cpu pulumi.IntInput `pulumi:"cpu"`
	// The description of the virtual machine workload, optional with no restrictions
	Description pulumi.StringPtrInput `pulumi:"description"`
	// The entry point for the flist. Example: /sbin/zinit init
	Entrypoint pulumi.StringPtrInput `pulumi:"entrypoint"`
	// The environment variables to be passed to the virtual machine. Example: SSH_KEY
	Env_vars pulumi.StringMapInput `pulumi:"env_vars"`
	// The flist to be mounted in the virtual machine, required and should be valid. Example: https://hub.grid.tf/tf-official-apps/base:latest.flist
	Flist pulumi.StringInput `pulumi:"flist"`
	// The checksum of the flist which should match the checksum of the given flist, optional
	Flist_checksum pulumi.StringPtrInput `pulumi:"flist_checksum"`
	// A list of gpu IDs to be used in the virtual machine. GPU ID format: <slot>/<vendor>/<device>. Example: 0000:28:00.0/1002/731f
	Gpus pulumi.StringArrayInput `pulumi:"gpus"`
	// The memory capacity for the virtual machine in MB. Min is 250 MB
	Memory pulumi.IntInput `pulumi:"memory"`
	// A list of mounted disks or volumes
	Mounts MountArrayInput `pulumi:"mounts"`
	// A flag to generate a random mycelium IP seed to support mycelium in the virtual machine
	Mycelium pulumi.BoolPtrInput `pulumi:"mycelium"`
	// The seed used for mycelium IP generated for the virtual machine. It's length should be 6
	Mycelium_ip_seed pulumi.StringPtrInput `pulumi:"mycelium_ip_seed"`
	// The name of the virtual machine workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
	Name pulumi.StringInput `pulumi:"name"`
	// The name of the network, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported. Network must exist
	Network_name pulumi.StringInput `pulumi:"network_name"`
	// The node ID to deploy the virtual machine on, required and should match the requested resources
	Node_id pulumi.Input `pulumi:"node_id"`
	// A flag to enable generating a yggdrasil IP for the virtual machine
	Planetary pulumi.BoolPtrInput `pulumi:"planetary"`
	// A flag to enable generating a public IP for the virtual machine, public node is required for it
	Public_ip pulumi.BoolPtrInput `pulumi:"public_ip"`
	// A flag to enable generating a public IPv6 for the virtual machine, public node is required for it
	Public_ip6 pulumi.BoolPtrInput `pulumi:"public_ip6"`
	// The root fs size in GB (type SSD). Can be set as 0 to get the default minimum
	Rootfs_size pulumi.IntPtrInput `pulumi:"rootfs_size"`
	// A list of virtual machine loggers
	Zlogs ZlogArrayInput `pulumi:"zlogs"`
}

func (VMInputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VMInput)(nil)).Elem()
}

func (i VMInputArgs) ToVMInputOutput() VMInputOutput {
	return i.ToVMInputOutputWithContext(context.Background())
}

func (i VMInputArgs) ToVMInputOutputWithContext(ctx context.Context) VMInputOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VMInputOutput)
}

// VMInputArrayInput is an input type that accepts VMInputArray and VMInputArrayOutput values.
// You can construct a concrete instance of `VMInputArrayInput` via:
//
//	VMInputArray{ VMInputArgs{...} }
type VMInputArrayInput interface {
	pulumi.Input

	ToVMInputArrayOutput() VMInputArrayOutput
	ToVMInputArrayOutputWithContext(context.Context) VMInputArrayOutput
}

type VMInputArray []VMInputInput

func (VMInputArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VMInput)(nil)).Elem()
}

func (i VMInputArray) ToVMInputArrayOutput() VMInputArrayOutput {
	return i.ToVMInputArrayOutputWithContext(context.Background())
}

func (i VMInputArray) ToVMInputArrayOutputWithContext(ctx context.Context) VMInputArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VMInputArrayOutput)
}

type VMInputOutput struct{ *pulumi.OutputState }

func (VMInputOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VMInput)(nil)).Elem()
}

func (o VMInputOutput) ToVMInputOutput() VMInputOutput {
	return o
}

func (o VMInputOutput) ToVMInputOutputWithContext(ctx context.Context) VMInputOutput {
	return o
}

// The cpu units needed for the virtual machine. Range in [1: 32]
func (o VMInputOutput) Cpu() pulumi.IntOutput {
	return o.ApplyT(func(v VMInput) int { return v.Cpu }).(pulumi.IntOutput)
}

// The description of the virtual machine workload, optional with no restrictions
func (o VMInputOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VMInput) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// The entry point for the flist. Example: /sbin/zinit init
func (o VMInputOutput) Entrypoint() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VMInput) *string { return v.Entrypoint }).(pulumi.StringPtrOutput)
}

// The environment variables to be passed to the virtual machine. Example: SSH_KEY
func (o VMInputOutput) Env_vars() pulumi.StringMapOutput {
	return o.ApplyT(func(v VMInput) map[string]string { return v.Env_vars }).(pulumi.StringMapOutput)
}

// The flist to be mounted in the virtual machine, required and should be valid. Example: https://hub.grid.tf/tf-official-apps/base:latest.flist
func (o VMInputOutput) Flist() pulumi.StringOutput {
	return o.ApplyT(func(v VMInput) string { return v.Flist }).(pulumi.StringOutput)
}

// The checksum of the flist which should match the checksum of the given flist, optional
func (o VMInputOutput) Flist_checksum() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VMInput) *string { return v.Flist_checksum }).(pulumi.StringPtrOutput)
}

// A list of gpu IDs to be used in the virtual machine. GPU ID format: <slot>/<vendor>/<device>. Example: 0000:28:00.0/1002/731f
func (o VMInputOutput) Gpus() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VMInput) []string { return v.Gpus }).(pulumi.StringArrayOutput)
}

// The memory capacity for the virtual machine in MB. Min is 250 MB
func (o VMInputOutput) Memory() pulumi.IntOutput {
	return o.ApplyT(func(v VMInput) int { return v.Memory }).(pulumi.IntOutput)
}

// A list of mounted disks or volumes
func (o VMInputOutput) Mounts() MountArrayOutput {
	return o.ApplyT(func(v VMInput) []Mount { return v.Mounts }).(MountArrayOutput)
}

// A flag to generate a random mycelium IP seed to support mycelium in the virtual machine
func (o VMInputOutput) Mycelium() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VMInput) *bool { return v.Mycelium }).(pulumi.BoolPtrOutput)
}

// The seed used for mycelium IP generated for the virtual machine. It's length should be 6
func (o VMInputOutput) Mycelium_ip_seed() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VMInput) *string { return v.Mycelium_ip_seed }).(pulumi.StringPtrOutput)
}

// The name of the virtual machine workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
func (o VMInputOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v VMInput) string { return v.Name }).(pulumi.StringOutput)
}

// The name of the network, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported. Network must exist
func (o VMInputOutput) Network_name() pulumi.StringOutput {
	return o.ApplyT(func(v VMInput) string { return v.Network_name }).(pulumi.StringOutput)
}

// The node ID to deploy the virtual machine on, required and should match the requested resources
func (o VMInputOutput) Node_id() pulumi.AnyOutput {
	return o.ApplyT(func(v VMInput) interface{} { return v.Node_id }).(pulumi.AnyOutput)
}

// A flag to enable generating a yggdrasil IP for the virtual machine
func (o VMInputOutput) Planetary() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VMInput) *bool { return v.Planetary }).(pulumi.BoolPtrOutput)
}

// A flag to enable generating a public IP for the virtual machine, public node is required for it
func (o VMInputOutput) Public_ip() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VMInput) *bool { return v.Public_ip }).(pulumi.BoolPtrOutput)
}

// A flag to enable generating a public IPv6 for the virtual machine, public node is required for it
func (o VMInputOutput) Public_ip6() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VMInput) *bool { return v.Public_ip6 }).(pulumi.BoolPtrOutput)
}

// The root fs size in GB (type SSD). Can be set as 0 to get the default minimum
func (o VMInputOutput) Rootfs_size() pulumi.IntPtrOutput {
	return o.ApplyT(func(v VMInput) *int { return v.Rootfs_size }).(pulumi.IntPtrOutput)
}

// A list of virtual machine loggers
func (o VMInputOutput) Zlogs() ZlogArrayOutput {
	return o.ApplyT(func(v VMInput) []Zlog { return v.Zlogs }).(ZlogArrayOutput)
}

type VMInputArrayOutput struct{ *pulumi.OutputState }

func (VMInputArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VMInput)(nil)).Elem()
}

func (o VMInputArrayOutput) ToVMInputArrayOutput() VMInputArrayOutput {
	return o
}

func (o VMInputArrayOutput) ToVMInputArrayOutputWithContext(ctx context.Context) VMInputArrayOutput {
	return o
}

func (o VMInputArrayOutput) Index(i pulumi.IntInput) VMInputOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VMInput {
		return vs[0].([]VMInput)[vs[1].(int)]
	}).(VMInputOutput)
}

type ZDBComputed struct {
	// Computed IPs of the ZDB. Two IPs are returned: a public IPv6, and a YggIP, in this order
	Ips []string `pulumi:"ips"`
	// Namespace of the ZDB
	Namespace string `pulumi:"namespace"`
	// Port of the ZDB
	Port int `pulumi:"port"`
}

// ZDBComputedInput is an input type that accepts ZDBComputedArgs and ZDBComputedOutput values.
// You can construct a concrete instance of `ZDBComputedInput` via:
//
//	ZDBComputedArgs{...}
type ZDBComputedInput interface {
	pulumi.Input

	ToZDBComputedOutput() ZDBComputedOutput
	ToZDBComputedOutputWithContext(context.Context) ZDBComputedOutput
}

type ZDBComputedArgs struct {
	// Computed IPs of the ZDB. Two IPs are returned: a public IPv6, and a YggIP, in this order
	Ips pulumi.StringArrayInput `pulumi:"ips"`
	// Namespace of the ZDB
	Namespace pulumi.StringInput `pulumi:"namespace"`
	// Port of the ZDB
	Port pulumi.IntInput `pulumi:"port"`
}

func (ZDBComputedArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ZDBComputed)(nil)).Elem()
}

func (i ZDBComputedArgs) ToZDBComputedOutput() ZDBComputedOutput {
	return i.ToZDBComputedOutputWithContext(context.Background())
}

func (i ZDBComputedArgs) ToZDBComputedOutputWithContext(ctx context.Context) ZDBComputedOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZDBComputedOutput)
}

// ZDBComputedArrayInput is an input type that accepts ZDBComputedArray and ZDBComputedArrayOutput values.
// You can construct a concrete instance of `ZDBComputedArrayInput` via:
//
//	ZDBComputedArray{ ZDBComputedArgs{...} }
type ZDBComputedArrayInput interface {
	pulumi.Input

	ToZDBComputedArrayOutput() ZDBComputedArrayOutput
	ToZDBComputedArrayOutputWithContext(context.Context) ZDBComputedArrayOutput
}

type ZDBComputedArray []ZDBComputedInput

func (ZDBComputedArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ZDBComputed)(nil)).Elem()
}

func (i ZDBComputedArray) ToZDBComputedArrayOutput() ZDBComputedArrayOutput {
	return i.ToZDBComputedArrayOutputWithContext(context.Background())
}

func (i ZDBComputedArray) ToZDBComputedArrayOutputWithContext(ctx context.Context) ZDBComputedArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZDBComputedArrayOutput)
}

type ZDBComputedOutput struct{ *pulumi.OutputState }

func (ZDBComputedOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ZDBComputed)(nil)).Elem()
}

func (o ZDBComputedOutput) ToZDBComputedOutput() ZDBComputedOutput {
	return o
}

func (o ZDBComputedOutput) ToZDBComputedOutputWithContext(ctx context.Context) ZDBComputedOutput {
	return o
}

// Computed IPs of the ZDB. Two IPs are returned: a public IPv6, and a YggIP, in this order
func (o ZDBComputedOutput) Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ZDBComputed) []string { return v.Ips }).(pulumi.StringArrayOutput)
}

// Namespace of the ZDB
func (o ZDBComputedOutput) Namespace() pulumi.StringOutput {
	return o.ApplyT(func(v ZDBComputed) string { return v.Namespace }).(pulumi.StringOutput)
}

// Port of the ZDB
func (o ZDBComputedOutput) Port() pulumi.IntOutput {
	return o.ApplyT(func(v ZDBComputed) int { return v.Port }).(pulumi.IntOutput)
}

type ZDBComputedArrayOutput struct{ *pulumi.OutputState }

func (ZDBComputedArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ZDBComputed)(nil)).Elem()
}

func (o ZDBComputedArrayOutput) ToZDBComputedArrayOutput() ZDBComputedArrayOutput {
	return o
}

func (o ZDBComputedArrayOutput) ToZDBComputedArrayOutputWithContext(ctx context.Context) ZDBComputedArrayOutput {
	return o
}

func (o ZDBComputedArrayOutput) Index(i pulumi.IntInput) ZDBComputedOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ZDBComputed {
		return vs[0].([]ZDBComputed)[vs[1].(int)]
	}).(ZDBComputedOutput)
}

type ZDBInput struct {
	// The description of the 0-db workload, optional with no restrictions
	Description *string `pulumi:"description"`
	// the enumeration of the modes 0-db can operate in (default user)
	Mode *string `pulumi:"mode"`
	// The name of the 0-db workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
	Name string `pulumi:"name"`
	// The 0-db password
	Password string `pulumi:"password"`
	// A flag to make 0-db namespace public - readable by anyone
	Public *bool `pulumi:"public"`
	// The 0-db size in GB (type HDD)
	Size int `pulumi:"size"`
}

// Defaults sets the appropriate defaults for ZDBInput
func (val *ZDBInput) Defaults() *ZDBInput {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		if d := internal.GetEnvOrDefault("user", nil, ""); d != nil {
			mode_ := d.(string)
			tmp.Mode = &mode_
		}
	}
	return &tmp
}

// ZDBInputInput is an input type that accepts ZDBInputArgs and ZDBInputOutput values.
// You can construct a concrete instance of `ZDBInputInput` via:
//
//	ZDBInputArgs{...}
type ZDBInputInput interface {
	pulumi.Input

	ToZDBInputOutput() ZDBInputOutput
	ToZDBInputOutputWithContext(context.Context) ZDBInputOutput
}

type ZDBInputArgs struct {
	// The description of the 0-db workload, optional with no restrictions
	Description pulumi.StringPtrInput `pulumi:"description"`
	// the enumeration of the modes 0-db can operate in (default user)
	Mode pulumi.StringPtrInput `pulumi:"mode"`
	// The name of the 0-db workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
	Name pulumi.StringInput `pulumi:"name"`
	// The 0-db password
	Password pulumi.StringInput `pulumi:"password"`
	// A flag to make 0-db namespace public - readable by anyone
	Public pulumi.BoolPtrInput `pulumi:"public"`
	// The 0-db size in GB (type HDD)
	Size pulumi.IntInput `pulumi:"size"`
}

// Defaults sets the appropriate defaults for ZDBInputArgs
func (val *ZDBInputArgs) Defaults() *ZDBInputArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		if d := internal.GetEnvOrDefault("user", nil, ""); d != nil {
			tmp.Mode = pulumi.StringPtr(d.(string))
		}
	}
	return &tmp
}
func (ZDBInputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ZDBInput)(nil)).Elem()
}

func (i ZDBInputArgs) ToZDBInputOutput() ZDBInputOutput {
	return i.ToZDBInputOutputWithContext(context.Background())
}

func (i ZDBInputArgs) ToZDBInputOutputWithContext(ctx context.Context) ZDBInputOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZDBInputOutput)
}

// ZDBInputArrayInput is an input type that accepts ZDBInputArray and ZDBInputArrayOutput values.
// You can construct a concrete instance of `ZDBInputArrayInput` via:
//
//	ZDBInputArray{ ZDBInputArgs{...} }
type ZDBInputArrayInput interface {
	pulumi.Input

	ToZDBInputArrayOutput() ZDBInputArrayOutput
	ToZDBInputArrayOutputWithContext(context.Context) ZDBInputArrayOutput
}

type ZDBInputArray []ZDBInputInput

func (ZDBInputArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ZDBInput)(nil)).Elem()
}

func (i ZDBInputArray) ToZDBInputArrayOutput() ZDBInputArrayOutput {
	return i.ToZDBInputArrayOutputWithContext(context.Background())
}

func (i ZDBInputArray) ToZDBInputArrayOutputWithContext(ctx context.Context) ZDBInputArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZDBInputArrayOutput)
}

type ZDBInputOutput struct{ *pulumi.OutputState }

func (ZDBInputOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ZDBInput)(nil)).Elem()
}

func (o ZDBInputOutput) ToZDBInputOutput() ZDBInputOutput {
	return o
}

func (o ZDBInputOutput) ToZDBInputOutputWithContext(ctx context.Context) ZDBInputOutput {
	return o
}

// The description of the 0-db workload, optional with no restrictions
func (o ZDBInputOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ZDBInput) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// the enumeration of the modes 0-db can operate in (default user)
func (o ZDBInputOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ZDBInput) *string { return v.Mode }).(pulumi.StringPtrOutput)
}

// The name of the 0-db workload, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
func (o ZDBInputOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ZDBInput) string { return v.Name }).(pulumi.StringOutput)
}

// The 0-db password
func (o ZDBInputOutput) Password() pulumi.StringOutput {
	return o.ApplyT(func(v ZDBInput) string { return v.Password }).(pulumi.StringOutput)
}

// A flag to make 0-db namespace public - readable by anyone
func (o ZDBInputOutput) Public() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ZDBInput) *bool { return v.Public }).(pulumi.BoolPtrOutput)
}

// The 0-db size in GB (type HDD)
func (o ZDBInputOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v ZDBInput) int { return v.Size }).(pulumi.IntOutput)
}

type ZDBInputArrayOutput struct{ *pulumi.OutputState }

func (ZDBInputArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ZDBInput)(nil)).Elem()
}

func (o ZDBInputArrayOutput) ToZDBInputArrayOutput() ZDBInputArrayOutput {
	return o
}

func (o ZDBInputArrayOutput) ToZDBInputArrayOutputWithContext(ctx context.Context) ZDBInputArrayOutput {
	return o
}

func (o ZDBInputArrayOutput) Index(i pulumi.IntInput) ZDBInputOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ZDBInput {
		return vs[0].([]ZDBInput)[vs[1].(int)]
	}).(ZDBInputOutput)
}

type Zlog struct {
	// The output logs URL, should be a valid url
	Output string `pulumi:"output"`
	// The name of virtual machine, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
	Zmachine string `pulumi:"zmachine"`
}

// ZlogInput is an input type that accepts ZlogArgs and ZlogOutput values.
// You can construct a concrete instance of `ZlogInput` via:
//
//	ZlogArgs{...}
type ZlogInput interface {
	pulumi.Input

	ToZlogOutput() ZlogOutput
	ToZlogOutputWithContext(context.Context) ZlogOutput
}

type ZlogArgs struct {
	// The output logs URL, should be a valid url
	Output pulumi.StringInput `pulumi:"output"`
	// The name of virtual machine, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
	Zmachine pulumi.StringInput `pulumi:"zmachine"`
}

func (ZlogArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Zlog)(nil)).Elem()
}

func (i ZlogArgs) ToZlogOutput() ZlogOutput {
	return i.ToZlogOutputWithContext(context.Background())
}

func (i ZlogArgs) ToZlogOutputWithContext(ctx context.Context) ZlogOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZlogOutput)
}

// ZlogArrayInput is an input type that accepts ZlogArray and ZlogArrayOutput values.
// You can construct a concrete instance of `ZlogArrayInput` via:
//
//	ZlogArray{ ZlogArgs{...} }
type ZlogArrayInput interface {
	pulumi.Input

	ToZlogArrayOutput() ZlogArrayOutput
	ToZlogArrayOutputWithContext(context.Context) ZlogArrayOutput
}

type ZlogArray []ZlogInput

func (ZlogArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Zlog)(nil)).Elem()
}

func (i ZlogArray) ToZlogArrayOutput() ZlogArrayOutput {
	return i.ToZlogArrayOutputWithContext(context.Background())
}

func (i ZlogArray) ToZlogArrayOutputWithContext(ctx context.Context) ZlogArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZlogArrayOutput)
}

type ZlogOutput struct{ *pulumi.OutputState }

func (ZlogOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Zlog)(nil)).Elem()
}

func (o ZlogOutput) ToZlogOutput() ZlogOutput {
	return o
}

func (o ZlogOutput) ToZlogOutputWithContext(ctx context.Context) ZlogOutput {
	return o
}

// The output logs URL, should be a valid url
func (o ZlogOutput) Output() pulumi.StringOutput {
	return o.ApplyT(func(v Zlog) string { return v.Output }).(pulumi.StringOutput)
}

// The name of virtual machine, it's required and cannot exceed 50 characters. Only alphanumeric and underscores characters are supported
func (o ZlogOutput) Zmachine() pulumi.StringOutput {
	return o.ApplyT(func(v Zlog) string { return v.Zmachine }).(pulumi.StringOutput)
}

type ZlogArrayOutput struct{ *pulumi.OutputState }

func (ZlogArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Zlog)(nil)).Elem()
}

func (o ZlogArrayOutput) ToZlogArrayOutput() ZlogArrayOutput {
	return o
}

func (o ZlogArrayOutput) ToZlogArrayOutputWithContext(ctx context.Context) ZlogArrayOutput {
	return o
}

func (o ZlogArrayOutput) Index(i pulumi.IntInput) ZlogOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Zlog {
		return vs[0].([]Zlog)[vs[1].(int)]
	}).(ZlogOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*BackendInput)(nil)).Elem(), BackendArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BackendArrayInput)(nil)).Elem(), BackendArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DiskInput)(nil)).Elem(), DiskArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DiskArrayInput)(nil)).Elem(), DiskArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GroupInput)(nil)).Elem(), GroupArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GroupArrayInput)(nil)).Elem(), GroupArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*K8sNodeInputInput)(nil)).Elem(), K8sNodeInputArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*K8sNodeInputArrayInput)(nil)).Elem(), K8sNodeInputArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetadataInput)(nil)).Elem(), MetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MountInput)(nil)).Elem(), MountArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MountArrayInput)(nil)).Elem(), MountArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*QSFSComputedInput)(nil)).Elem(), QSFSComputedArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*QSFSComputedArrayInput)(nil)).Elem(), QSFSComputedArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*QSFSInputInput)(nil)).Elem(), QSFSInputArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*QSFSInputArrayInput)(nil)).Elem(), QSFSInputArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VMComputedInput)(nil)).Elem(), VMComputedArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VMComputedArrayInput)(nil)).Elem(), VMComputedArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VMComputedMapInput)(nil)).Elem(), VMComputedMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*VMInputInput)(nil)).Elem(), VMInputArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VMInputArrayInput)(nil)).Elem(), VMInputArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ZDBComputedInput)(nil)).Elem(), ZDBComputedArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ZDBComputedArrayInput)(nil)).Elem(), ZDBComputedArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ZDBInputInput)(nil)).Elem(), ZDBInputArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ZDBInputArrayInput)(nil)).Elem(), ZDBInputArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ZlogInput)(nil)).Elem(), ZlogArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ZlogArrayInput)(nil)).Elem(), ZlogArray{})
	pulumi.RegisterOutputType(BackendOutput{})
	pulumi.RegisterOutputType(BackendArrayOutput{})
	pulumi.RegisterOutputType(DiskOutput{})
	pulumi.RegisterOutputType(DiskArrayOutput{})
	pulumi.RegisterOutputType(GroupOutput{})
	pulumi.RegisterOutputType(GroupArrayOutput{})
	pulumi.RegisterOutputType(K8sNodeInputOutput{})
	pulumi.RegisterOutputType(K8sNodeInputArrayOutput{})
	pulumi.RegisterOutputType(MetadataOutput{})
	pulumi.RegisterOutputType(MountOutput{})
	pulumi.RegisterOutputType(MountArrayOutput{})
	pulumi.RegisterOutputType(QSFSComputedOutput{})
	pulumi.RegisterOutputType(QSFSComputedArrayOutput{})
	pulumi.RegisterOutputType(QSFSInputOutput{})
	pulumi.RegisterOutputType(QSFSInputArrayOutput{})
	pulumi.RegisterOutputType(VMComputedOutput{})
	pulumi.RegisterOutputType(VMComputedArrayOutput{})
	pulumi.RegisterOutputType(VMComputedMapOutput{})
	pulumi.RegisterOutputType(VMInputOutput{})
	pulumi.RegisterOutputType(VMInputArrayOutput{})
	pulumi.RegisterOutputType(ZDBComputedOutput{})
	pulumi.RegisterOutputType(ZDBComputedArrayOutput{})
	pulumi.RegisterOutputType(ZDBInputOutput{})
	pulumi.RegisterOutputType(ZDBInputArrayOutput{})
	pulumi.RegisterOutputType(ZlogOutput{})
	pulumi.RegisterOutputType(ZlogArrayOutput{})
}
